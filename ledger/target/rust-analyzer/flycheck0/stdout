{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proc-macro2-1.0.103/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proc-macro2-1.0.103/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","proc-macro"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/proc-macro2-d1ce00ff3654ae6d/build-script-build"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","linked_libs":[],"linked_paths":[],"cfgs":["wrap_proc_macro","proc_macro_span_location","proc_macro_span_file"],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/proc-macro2-02343e2882138b6d/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.42/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.42/build.rs","edition":"2018","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","proc-macro"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/quote-c88cbe7a015637c2/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.22","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-ident-1.0.22/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"unicode_ident","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-ident-1.0.22/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libunicode_ident-ff24541d0273ed5a.rlib","/Users/charles/Code/pallas-extras/target/debug/deps/libunicode_ident-ff24541d0273ed5a.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libc@0.2.177","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.177/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.177/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/libc-82ecf85ae65debb7/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.4","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cfg-if-1.0.4/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"cfg_if","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cfg-if-1.0.4/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcfg_if-eed30869daa6a03e.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#subtle@2.6.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/subtle-2.6.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"subtle","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/subtle-2.6.1/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["const-generics","default","i128","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libsubtle-1d6dff69cce4f757.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#typenum@1.19.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/typenum-1.19.0/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/typenum-1.19.0/build.rs","edition":"2018","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["const-generics"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/typenum-d11561de1d76fbb3/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#const-oid@0.10.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/const-oid-0.10.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"const_oid","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/const-oid-0.10.1/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libconst_oid-7a9f99b2b613243f.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#getrandom@0.3.4","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.3.4/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.3.4/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/getrandom-56d7d2627dc4a0c0/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#zerocopy@0.8.27","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zerocopy-0.8.27/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zerocopy-0.8.27/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["derive","simd","zerocopy-derive"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/zerocopy-2bf57559c710ab12/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proc-macro2-1.0.103/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"proc_macro2","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proc-macro2-1.0.103/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","proc-macro"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libproc_macro2-028483108b7d1ae7.rlib","/Users/charles/Code/pallas-extras/target/debug/deps/libproc_macro2-028483108b7d1ae7.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","linked_libs":[],"linked_paths":[],"cfgs":[],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/quote-81aa7bbf6f05440f/out"}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#libc@0.2.177","linked_libs":[],"linked_paths":[],"cfgs":["freebsd12"],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/libc-07b709c9d10b7700/out"}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#typenum@1.19.0","linked_libs":[],"linked_paths":[],"cfgs":[],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/typenum-dd22c81088b928c2/out"}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#getrandom@0.3.4","linked_libs":[],"linked_paths":[],"cfgs":[],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/getrandom-fefaccf92a17ee8c/out"}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#zerocopy@0.8.27","linked_libs":[],"linked_paths":[],"cfgs":["zerocopy_core_error_1_81_0","zerocopy_diagnostic_on_unimplemented_1_78_0","zerocopy_generic_bounds_in_const_fn_1_61_0","zerocopy_target_has_atomics_1_60_0","zerocopy_aarch64_simd_1_59_0","zerocopy_panic_in_const_and_vec_try_reserve_1_57_0"],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/zerocopy-498fac5aa678a687/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#autocfg@1.5.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/autocfg-1.5.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"autocfg","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/autocfg-1.5.0/src/lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libautocfg-e2e21eab783460c2.rlib","/Users/charles/Code/pallas-extras/target/debug/deps/libautocfg-e2e21eab783460c2.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#radium@0.7.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/radium-0.7.0/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/radium-0.7.0/build.rs","edition":"2018","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/radium-fc8feee292facca0/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#tap@1.0.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tap-1.0.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tap","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tap-1.0.1/src/lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libtap-97c8ea1255426417.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#semver@1.0.27","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/semver-1.0.27/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"semver","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/semver-1.0.27/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libsemver-b13c99745d8a0cf7.rlib","/Users/charles/Code/pallas-extras/target/debug/deps/libsemver-b13c99745d8a0cf7.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.42/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"quote","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.42/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","proc-macro"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libquote-b0045370011366e6.rlib","/Users/charles/Code/pallas-extras/target/debug/deps/libquote-b0045370011366e6.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libc@0.2.177","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.177/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"libc","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.177/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/liblibc-49ac093dc3ce2f23.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#typenum@1.19.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/typenum-1.19.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"typenum","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/typenum-1.19.0/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["const-generics"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libtypenum-c94f4c3cf1f3c98b.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.19","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/num-traits-151c990202d10603/build-script-build"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#radium@0.7.0","linked_libs":[],"linked_paths":[],"cfgs":["radium_atomic_8","radium_atomic_16","radium_atomic_32","radium_atomic_64","radium_atomic_ptr"],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/radium-48d5e218e050cd39/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rustc_version@0.4.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustc_version-0.4.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"rustc_version","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustc_version-0.4.1/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/librustc_version-4fabf10030d7a286.rlib","/Users/charles/Code/pallas-extras/target/debug/deps/librustc_version-4fabf10030d7a286.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#wyz@0.5.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/wyz-0.5.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"wyz","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/wyz-0.5.1/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libwyz-9f6a2d146430c9e0.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#funty@2.0.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/funty-2.0.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"funty","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/funty-2.0.0/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libfunty-698c07373af59198.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ref-cast@1.0.25","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ref-cast-1.0.25/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ref-cast-1.0.25/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/ref-cast-2dc664b8f2af388a/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#gmp-mpfr-sys@1.6.8","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gmp-mpfr-sys-1.6.8/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gmp-mpfr-sys-1.6.8/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/gmp-mpfr-sys-0faaf3c447040ebe/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#syn@2.0.110","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/syn-2.0.110/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"syn","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/syn-2.0.110/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["clone-impls","default","derive","extra-traits","full","parsing","printing","proc-macro","visit","visit-mut"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libsyn-9465b88997c2cdaa.rlib","/Users/charles/Code/pallas-extras/target/debug/deps/libsyn-9465b88997c2cdaa.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#getrandom@0.3.4","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.3.4/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"getrandom","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.3.4/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libgetrandom-2ccfa2a5106e452e.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#cpufeatures@0.2.17","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cpufeatures-0.2.17/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"cpufeatures","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cpufeatures-0.2.17/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcpufeatures-7067440832f3a4cc.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.19","linked_libs":[],"linked_paths":[],"cfgs":["has_total_cmp"],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/num-traits-da6afca2f0b36689/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#radium@0.7.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/radium-0.7.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"radium","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/radium-0.7.0/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libradium-ec385815d5d60579.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#curve25519-dalek@5.0.0-pre.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/curve25519-dalek-5.0.0-pre.1/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/curve25519-dalek-5.0.0-pre.1/build.rs","edition":"2024","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","digest"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/curve25519-dalek-16c9cec925b977bd/build-script-build"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#ref-cast@1.0.25","linked_libs":[],"linked_paths":[],"cfgs":[],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/ref-cast-2f5b6e98b55d51e6/out"}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#gmp-mpfr-sys@1.6.8","linked_libs":["static=gmp"],"linked_paths":["native=/Users/charles/Code/pallas-extras/target/debug/build/gmp-mpfr-sys-d4f423981622cd26/out/lib"],"cfgs":[],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/gmp-mpfr-sys-d4f423981622cd26/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libm@0.2.15","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libm-0.2.15/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libm-0.2.15/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["arch","default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/libm-8347d66355d0f5a0/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#find-msvc-tools@0.1.5","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/find-msvc-tools-0.1.5/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"find_msvc_tools","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/find-msvc-tools-0.1.5/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libfind_msvc_tools-097a342ea7647ca5.rlib","/Users/charles/Code/pallas-extras/target/debug/deps/libfind_msvc_tools-097a342ea7647ca5.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#zeroize_derive@1.4.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize_derive-1.4.2/Cargo.toml","target":{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"zeroize_derive","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize_derive-1.4.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libzeroize_derive-110637ac17261136.dylib"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#zerocopy-derive@0.8.27","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zerocopy-derive-0.8.27/Cargo.toml","target":{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"zerocopy_derive","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zerocopy-derive-0.8.27/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libzerocopy_derive-53ea5e58e8cae2a5.dylib"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rand_core@0.9.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_core-0.9.3/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"rand_core","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_core-0.9.3/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["os_rng","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/librand_core-75d5fa15ee99a9cd.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.19","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"num_traits","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libnum_traits-60c04ad9e53f4206.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#bitvec@1.0.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bitvec-1.0.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bitvec","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bitvec-1.0.1/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libbitvec-15f1c8283d47eced.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#minicbor-derive@0.18.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/Cargo.toml","target":{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"minicbor_derive","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libminicbor_derive-8226b80707f98a9b.dylib"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#curve25519-dalek@5.0.0-pre.1","linked_libs":[],"linked_paths":[],"cfgs":["curve25519_dalek_bits=\"64\"","curve25519_dalek_backend=\"serial\""],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/curve25519-dalek-2ea29a6e22883565/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ref-cast-impl@1.0.25","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ref-cast-impl-1.0.25/Cargo.toml","target":{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"ref_cast_impl","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ref-cast-impl-1.0.25/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libref_cast_impl-bbd72c1862988008.dylib"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#either@1.15.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/either-1.15.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"either","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/either-1.15.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std","use_std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libeither-db16f385ad009751.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#paste@1.0.15","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/paste-1.0.15/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/paste-1.0.15/build.rs","edition":"2018","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/paste-f82aef9020a4f8a4/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#zeroize@1.8.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"zeroize","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","default","zeroize_derive"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libzeroize-6868896b49203c12.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#zerocopy@0.8.27","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zerocopy-0.8.27/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"zerocopy","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zerocopy-0.8.27/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["derive","simd","zerocopy-derive"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libzerocopy-fad2ec59f737bc47.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ff@0.14.0-pre.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ff-0.14.0-pre.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ff","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ff-0.14.0-pre.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","bits","bitvec","default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libff-97c42588dc4b84ba.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rand_xorshift@0.4.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_xorshift-0.4.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"rand_xorshift","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_xorshift-0.4.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/librand_xorshift-739c5b513d22e253.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#az@1.2.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/az-1.2.1/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/az-1.2.1/build.rs","edition":"2018","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/az-f0435aca0e8a1f1b/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#shlex@1.3.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/shlex-1.3.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"shlex","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/shlex-1.3.0/src/lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libshlex-712ea22829555143.rlib","/Users/charles/Code/pallas-extras/target/debug/deps/libshlex-712ea22829555143.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ref-cast@1.0.25","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ref-cast-1.0.25/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ref_cast","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ref-cast-1.0.25/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libref_cast-458c2ff9ee7de141.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#paste@1.0.15","linked_libs":[],"linked_paths":[],"cfgs":[],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/paste-39e5975b0310bb53/out"}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#libm@0.2.15","linked_libs":[],"linked_paths":[],"cfgs":["arch_enabled"],"env":[["CFG_CARGO_FEATURES","[\"arch\", \"default\"]"],["CFG_OPT_LEVEL","0"],["CFG_TARGET_FEATURES","[\"aes\", \"crc\", \"dit\", \"dotprod\", \"dpb\", \"dpb2\", \"fcma\", \"fhm\", \"flagm\", \"fp16\", \"frintts\", \"jsconv\", \"lor\", \"lse\", \"neon\", \"paca\", \"pacg\", \"pan\", \"pmuv3\", \"ras\", \"rcpc\", \"rcpc2\", \"rdm\", \"sb\", \"sha2\", \"sha3\", \"ssbs\", \"vh\"]"]],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/libm-6936e93799ecc438/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rug@1.28.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rug-1.28.0/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rug-1.28.0/build.rs","edition":"2024","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["gmp-mpfr-sys","integer","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/rug-1dbb21319cb4877b/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#hybrid-array@0.4.5","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hybrid-array-0.4.5/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"hybrid_array","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hybrid-array-0.4.5/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","subtle","zeroize"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libhybrid_array-591af5833b386ead.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ppv-lite86@0.2.21","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ppv-lite86-0.2.21/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ppv_lite86","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ppv-lite86-0.2.21/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["simd","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libppv_lite86-a89ba3a7934176df.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#half@2.7.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/half-2.7.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"half","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/half-2.7.1/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libhalf-51130f7ff9e9ae5d.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#der@0.8.0-rc.10","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.8.0-rc.10/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"der","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.8.0-rc.10/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","oid","std","zeroize"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libder-45f5038ff09cb85d.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#cc@1.2.46","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cc-1.2.46/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"cc","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cc-1.2.46/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcc-74c011ae80834218.rlib","/Users/charles/Code/pallas-extras/target/debug/deps/libcc-74c011ae80834218.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#az@1.2.1","linked_libs":[],"linked_paths":[],"cfgs":["track_caller"],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/az-e541b4a32fe0a5ea/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#base16ct@0.3.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/base16ct-0.3.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"base16ct","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/base16ct-0.3.0/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libbase16ct-bbe90ea3464b98a6.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#thiserror@2.0.17","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thiserror-2.0.17/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thiserror-2.0.17/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/thiserror-226389cc45301ea7/build-script-build"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#rug@1.28.0","linked_libs":[],"linked_paths":[],"cfgs":["gmp_limb_bits_64"],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/rug-a1cb4560ecae2263/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#paste@1.0.15","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/paste-1.0.15/Cargo.toml","target":{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"paste","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/paste-1.0.15/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libpaste-0df8339b25fae462.dylib"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#crypto-common@0.2.0-rc.5","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crypto-common-0.2.0-rc.5/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"crypto_common","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crypto-common-0.2.0-rc.5/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcrypto_common-18b0e1fcc25e7eff.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#block-buffer@0.11.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/block-buffer-0.11.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"block_buffer","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/block-buffer-0.11.0/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libblock_buffer-159d8d090588c355.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rand_chacha@0.9.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_chacha-0.9.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"rand_chacha","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_chacha-0.9.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/librand_chacha-14952d341087a228.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#minicbor@2.1.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"minicbor","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","derive","full","half","minicbor-derive","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libminicbor-0be462c4e06ecc63.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#spki@0.8.0-rc.4","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/spki-0.8.0-rc.4/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"spki","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/spki-0.8.0-rc.4/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libspki-be24f068f826e974.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#blst@0.3.16","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/blst-0.3.16/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/blst-0.3.16/build.rs","edition":"2018","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/blst-739b5934a8ea1fa5/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#az@1.2.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/az-1.2.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"az","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/az-1.2.1/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libaz-308a778a16bfc004.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#crypto-bigint@0.7.0-rc.9","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crypto-bigint-0.7.0-rc.9/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"crypto_bigint","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crypto-bigint-0.7.0-rc.9/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["hybrid-array","rand_core","zeroize"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcrypto_bigint-e414d67fc27785ee.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#thiserror@2.0.17","linked_libs":[],"linked_paths":[],"cfgs":[],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/thiserror-00cde9081ee0f228/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#sec1@0.8.0-rc.10","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sec1-0.8.0-rc.10/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"sec1","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sec1-0.8.0-rc.10/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","default","der","point","std","subtle","zeroize"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libsec1-37488ea9a8166e43.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#digest@0.11.0-rc.4","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/digest-0.11.0-rc.4/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"digest","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/digest-0.11.0-rc.4/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","block-api","block-buffer","const-oid","default","mac","oid","subtle"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libdigest-86c865cd890999d1.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rand@0.9.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand-0.9.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"rand","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand-0.9.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","default","os_rng","small_rng","std","std_rng","thread_rng"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/librand-0c94f7cdbf167c09.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#pkcs8@0.11.0-rc.8","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pkcs8-0.11.0-rc.8/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"pkcs8","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pkcs8-0.11.0-rc.8/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libpkcs8-056739d210e17d28.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libm@0.2.15","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libm-0.2.15/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"libm","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libm-0.2.15/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["arch","default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/liblibm-6a435010afcb19bd.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#thiserror-impl@2.0.17","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thiserror-impl-2.0.17/Cargo.toml","target":{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"thiserror_impl","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thiserror-impl-2.0.17/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libthiserror_impl-de1619b4f0b9d333.dylib"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#gmp-mpfr-sys@1.6.8","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gmp-mpfr-sys-1.6.8/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"gmp_mpfr_sys","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gmp-mpfr-sys-1.6.8/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libgmp_mpfr_sys-ba316f004ee10c06.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#num_cpus@1.17.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num_cpus-1.17.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"num_cpus","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num_cpus-1.17.0/src/lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libnum_cpus-67309529e2bdb6e2.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#macro_rules_attribute-proc_macro@0.2.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/macro_rules_attribute-proc_macro-0.2.2/Cargo.toml","target":{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"macro_rules_attribute_proc_macro","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/macro_rules_attribute-proc_macro-0.2.2/mod.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libmacro_rules_attribute_proc_macro-2027652d67f45d0b.dylib"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#heck@0.5.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/heck-0.5.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"heck","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/heck-0.5.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libheck-99fa9ad8066eb37c.rlib","/Users/charles/Code/pallas-extras/target/debug/deps/libheck-99fa9ad8066eb37c.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#embedded-io@0.7.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/embedded-io-0.7.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"embedded_io","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/embedded-io-0.7.1/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libembedded_io-bcb94a1882835001.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#sha2@0.11.0-rc.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sha2-0.11.0-rc.3/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"sha2","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sha2-0.11.0-rc.3/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libsha2-9709a7526c013ff2.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#signature@3.0.0-rc.4","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/signature-3.0.0-rc.4/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"signature","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/signature-3.0.0-rc.4/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","digest","rand_core"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libsignature-8174240e8bd0b3bd.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#hmac@0.13.0-rc.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hmac-0.13.0-rc.3/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"hmac","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hmac-0.13.0-rc.3/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libhmac-87e8bfea834614fb.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#curve25519-dalek@5.0.0-pre.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/curve25519-dalek-5.0.0-pre.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"curve25519_dalek","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/curve25519-dalek-5.0.0-pre.1/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","digest"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcurve25519_dalek-d5a6bf903b6ce663.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#group@0.14.0-pre.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/group-0.14.0-pre.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"group","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/group-0.14.0-pre.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","default","rand","rand_xorshift","tests"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libgroup-ed6052ea46eb389f.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#anstyle@1.0.13","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstyle-1.0.13/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"anstyle","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstyle-1.0.13/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libanstyle-440ef011c636d365.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#threadpool@1.8.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/threadpool-1.8.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"threadpool","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/threadpool-1.8.1/src/lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libthreadpool-38521637c21e999d.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rug@1.28.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rug-1.28.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"rug","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rug-1.28.0/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["gmp-mpfr-sys","integer","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/librug-59e908f91d9ed770.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#macro_rules_attribute@0.2.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/macro_rules_attribute-0.2.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"macro_rules_attribute","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/macro_rules_attribute-0.2.2/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libmacro_rules_attribute-a8ecb45e97dad381.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#tinycbor@0.2.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinycbor-0.2.3/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tinycbor","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinycbor-0.2.3/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libtinycbor-cb014f988cf73472.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ed25519@3.0.0-rc.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ed25519-3.0.0-rc.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ed25519","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ed25519-3.0.0-rc.1/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libed25519-455fd5842879f5bf.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#elliptic-curve@0.14.0-rc.16","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/elliptic-curve-0.14.0-rc.16/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"elliptic_curve","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/elliptic-curve-0.14.0-rc.16/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","arithmetic","basepoint-table","digest","ff","group","pkcs8","sec1","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libelliptic_curve-d260423d0634e405.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rfc6979@0.5.0-rc.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rfc6979-0.5.0-rc.3/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"rfc6979","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rfc6979-0.5.0-rc.3/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/librfc6979-1c153da348de7e96.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#thiserror@2.0.17","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thiserror-2.0.17/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"thiserror","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thiserror-2.0.17/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libthiserror-f0f537de487dc793.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#blake2@0.11.0-rc.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/blake2-0.11.0-rc.3/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"blake2","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/blake2-0.11.0-rc.3/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libblake2-23733d0a872f94f6.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#blst@0.3.16","linked_libs":["static=blst"],"linked_paths":["native=/Users/charles/Code/pallas-extras/target/debug/build/blst-ac32937060f7ad80/out"],"cfgs":["feature=\"std\""],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/blst-ac32937060f7ad80/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#const-hex@1.17.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/const-hex-1.17.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"const_hex","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/const-hex-1.17.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libconst_hex-9c880d5b68057bca.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-utils-0.8.21/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-utils-0.8.21/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/crossbeam-utils-6d0c505069b87f3f/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","result","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/serde_core-b0753111d424f06e/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#pairing@0.24.0-pre.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pairing-0.24.0-pre.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"pairing","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pairing-0.24.0-pre.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libpairing-f883b7ce0fa30709.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ed25519-dalek@3.0.0-pre.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ed25519-dalek-3.0.0-pre.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ed25519_dalek","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ed25519-dalek-3.0.0-pre.1/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","signature"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libed25519_dalek-896081b59fdc573f.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ecdsa@0.17.0-rc.8","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ecdsa-0.17.0-rc.8/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ecdsa","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ecdsa-0.17.0-rc.8/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["algorithm","alloc","der","digest","hazmat","pkcs8","spki","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libecdsa-22b8b262fa817e5f.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#blst@0.3.16","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/blst-0.3.16/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"blst","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/blst-0.3.16/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libblst-161128c5628cfae9.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21","linked_libs":[],"linked_paths":[],"cfgs":[],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/crossbeam-utils-fb91737d6607221c/out"}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228","linked_libs":[],"linked_paths":[],"cfgs":[],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/serde_core-4bdf6487753557d2/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#strum_macros@0.27.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/strum_macros-0.27.2/Cargo.toml","target":{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"strum_macros","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/strum_macros-0.27.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libstrum_macros-444ef1ff3997fe9f.dylib"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#keccak@0.2.0-rc.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/keccak-0.2.0-rc.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"keccak","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/keccak-0.2.0-rc.0/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libkeccak-ac6ffdbf3924a148.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#byte-slice-cast@1.2.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/byte-slice-cast-1.2.3/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"byte_slice_cast","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/byte-slice-cast-1.2.3/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libbyte_slice_cast-47b93539ebd1a733.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/cbor-util#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/cbor-util/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"cbor_util","src_path":"/Users/charles/Code/pallas-extras/cbor-util/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcbor_util-a8b35d4de959839a.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#pbkdf2@0.13.0-rc.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pbkdf2-0.13.0-rc.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"pbkdf2","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pbkdf2-0.13.0-rc.2/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","hmac"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libpbkdf2-19920e5142666aaf.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde_core","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","result","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libserde_core-d449c5cde8501661.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"git+https://github.com/carloskiki/blstrs#0.8.0-pre.0","manifest_path":"/Users/charles/.cargo/git/checkouts/blstrs-099da852b2e060c6/5ab417c/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"blstrs","src_path":"/Users/charles/.cargo/git/checkouts/blstrs-099da852b2e060c6/5ab417c/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libblstrs-fa8300ac3ed59a1a.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#k256@0.14.0-rc.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/k256-0.14.0-rc.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"k256","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/k256-0.14.0-rc.0/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","arithmetic","default","digest","ecdsa","ecdsa-core","pkcs8","precomputed-tables","schnorr","sha2","sha256","signature","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libk256-c2658b68a8207d1c.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#strum@0.27.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/strum-0.27.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strum","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/strum-0.27.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","derive","std","strum_macros"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libstrum-b89fec787ab133d5.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-utils-0.8.21/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"crossbeam_utils","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-utils-0.8.21/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcrossbeam_utils-caa8cfc45f06ae2a.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#sha3@0.11.0-rc.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sha3-0.11.0-rc.3/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"sha3","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sha3-0.11.0-rc.3/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libsha3-9a81b0c728200b15.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#tinycbor-derive@0.2.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinycbor-derive-0.2.3/Cargo.toml","target":{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"tinycbor_derive","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinycbor-derive-0.2.3/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libtinycbor_derive-093029b2f45f84b7.dylib"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ripemd@0.2.0-rc.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ripemd-0.2.0-rc.3/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ripemd","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ripemd-0.2.0-rc.3/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","default","oid"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libripemd-063fcc480ca69d28.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#log@0.4.28","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/log-0.4.28/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"log","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/log-0.4.28/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/liblog-28fe24761d16d199.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#lexarg-parser@0.0.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexarg-parser-0.0.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"lexarg_parser","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexarg-parser-0.0.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/liblexarg_parser-38ec7bbd1e84f8e8.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#serde@1.0.228","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","default","derive","serde_derive","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/serde-ecd9eabf8fe98ee3/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#lexarg-error@0.0.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexarg-error-0.0.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"lexarg_error","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexarg-error-0.0.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/liblexarg_error-7a2b4e08431b5df7.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-epoch@0.9.18","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-epoch-0.9.18/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"crossbeam_epoch","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-epoch-0.9.18/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcrossbeam_epoch-9c36ae68c05dbbd3.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#serde_derive@1.0.228","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_derive-1.0.228/Cargo.toml","target":{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"serde_derive","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_derive-1.0.228/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libserde_derive-bb0328d8d70ef4b6.dylib"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#crc32fast@1.5.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crc32fast-1.5.0/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crc32fast-1.5.0/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/crc32fast-805e2d8b36128073/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#utf8parse@0.2.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/utf8parse-0.2.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"utf8parse","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/utf8parse-0.2.2/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libutf8parse-6789f08867d8c1a9.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rayon-core@1.13.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-core-1.13.0/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-core-1.13.0/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/rayon-core-66393fd3ff70fbcc/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#serde_json@1.0.145","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_json-1.0.145/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_json-1.0.145/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/serde_json-070dabf5ff6dc429/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/plutus#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/plutus/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"plutus","src_path":"/Users/charles/Code/pallas-extras/plutus/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libplutus-bf544d862d730751.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/bip32#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/bip32/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bip32","src_path":"/Users/charles/Code/pallas-extras/bip32/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libbip32-7d6cbc55ffa100ba.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#serde@1.0.228","linked_libs":[],"linked_paths":[],"cfgs":["if_docsrs_then_no_serde_core"],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/serde-7ceb09fb5009e528/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#lexarg@0.0.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexarg-0.0.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"lexarg","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexarg-0.0.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/liblexarg-a0316611ee2c2cba.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#anstyle-parse@0.2.7","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstyle-parse-0.2.7/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"anstyle_parse","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstyle-parse-0.2.7/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","utf8"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libanstyle_parse-25cab134895a6853.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#rayon-core@1.13.0","linked_libs":[],"linked_paths":[],"cfgs":[],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/rayon-core-06da785709dbc36e/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-deque@0.8.6","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-deque-0.8.6/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"crossbeam_deque","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-deque-0.8.6/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcrossbeam_deque-c16017a42af09801.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#crc32fast@1.5.0","linked_libs":[],"linked_paths":[],"cfgs":["stable_arm_crc32_intrinsics"],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/crc32fast-1d6535bf9e6772b9/out"}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#serde_json@1.0.145","linked_libs":[],"linked_paths":[],"cfgs":["fast_arithmetic=\"64\""],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/serde_json-56098e60694e05a6/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#plotters-backend@0.3.7","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/plotters-backend-0.3.7/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"plotters_backend","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/plotters-backend-0.3.7/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libplotters_backend-e2de490f33e8365d.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ciborium-io@0.2.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ciborium-io-0.2.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ciborium_io","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ciborium-io-0.2.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libciborium_io-8ddccaf02fa2dabf.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.6","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memchr-2.7.6/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"memchr","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memchr-2.7.6/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libmemchr-867c662323befbc1.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#serde@1.0.228","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","default","derive","serde_derive","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libserde-b5963448ac695691.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#itoa@1.0.15","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/itoa-1.0.15/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"itoa","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/itoa-1.0.15/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libitoa-aac1ae89bc8c8867.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ryu@1.0.20","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ryu-1.0.20/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ryu","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ryu-1.0.20/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libryu-5dca68e756b6c3fe.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#anyhow@1.0.100","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anyhow-1.0.100/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anyhow-1.0.100/build.rs","edition":"2018","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/build/anyhow-d1fe93c1d941837b/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#clap_lex@0.7.6","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap_lex-0.7.6/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"clap_lex","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap_lex-0.7.6/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libclap_lex-5523af2f3124e780.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#regex-syntax@0.8.8","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.8/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"regex_syntax","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.8/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libregex_syntax-a87402582f25fabe.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#json-write@0.0.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/json-write-0.0.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"json_write","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/json-write-0.0.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libjson_write-a1ae4e61978538d9.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#colorchoice@1.0.4","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/colorchoice-1.0.4/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"colorchoice","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/colorchoice-1.0.4/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcolorchoice-c7ddccf29e4b7158.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#is_terminal_polyfill@1.70.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/is_terminal_polyfill-1.70.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"is_terminal_polyfill","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/is_terminal_polyfill-1.70.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libis_terminal_polyfill-c072f7d8ae94dd01.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#anstyle-query@1.1.5","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstyle-query-1.1.5/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"anstyle_query","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstyle-query-1.1.5/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libanstyle_query-740c22041c9d4d41.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#regex-automata@0.4.13","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.13/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"regex_automata","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.13/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","meta","nfa-pikevm","nfa-thompson","std","syntax"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libregex_automata-e206950956956a65.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#serde_json@1.0.145","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_json-1.0.145/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde_json","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_json-1.0.145/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libserde_json-88dd7061c1c2df1e.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#anyhow@1.0.100","linked_libs":[],"linked_paths":[],"cfgs":["std_backtrace"],"env":[],"out_dir":"/Users/charles/Code/pallas-extras/target/debug/build/anyhow-383c37c97ff371e9/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#clap_builder@4.5.53","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap_builder-4.5.53/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"clap_builder","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap_builder-4.5.53/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["help","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libclap_builder-3f824052b89083bd.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libtest-json@0.0.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libtest-json-0.0.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"libtest_json","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libtest-json-0.0.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","json"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/liblibtest_json-a45cc36ce91049cf.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#anstream@0.6.21","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstream-0.6.21/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"anstream","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstream-0.6.21/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["auto","default","wincon"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libanstream-a657c0a9fdb76ed3.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libtest-lexarg@0.0.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libtest-lexarg-0.0.3/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"libtest_lexarg","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libtest-lexarg-0.0.3/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/liblibtest_lexarg-6780408bdbd18553.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#crc32fast@1.5.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crc32fast-1.5.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"crc32fast","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crc32fast-1.5.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcrc32fast-7ae61665bc970807.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rayon-core@1.13.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-core-1.13.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"rayon_core","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-core-1.13.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/librayon_core-0b35ed4d486fc6e9.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ciborium-ll@0.2.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ciborium-ll-0.2.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ciborium_ll","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ciborium-ll-0.2.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libciborium_ll-646b28aabdc2ace3.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#plotters-svg@0.3.7","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/plotters-svg-0.3.7/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"plotters_svg","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/plotters-svg-0.3.7/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libplotters_svg-4075f1a41488548d.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/kes#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/kes/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"kes","src_path":"/Users/charles/Code/pallas-extras/kes/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libkes-55ff0b912d5a9078.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#itertools@0.13.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/itertools-0.13.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"itertools","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/itertools-0.13.0/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":false},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","use_alloc","use_std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libitertools-767ee87340959c6b.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#bech32@0.11.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bech32-0.11.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bech32","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bech32-0.11.0/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libbech32-d90dd3d2f8ee50ca.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#same-file@1.0.6","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/same-file-1.0.6/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"same_file","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/same-file-1.0.6/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libsame_file-1a494771e40bea10.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#cast@0.3.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cast-0.3.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"cast","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cast-0.3.0/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcast-027321e6601be789.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#bs58@0.5.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bs58-0.5.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bs58","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bs58-0.5.1/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["alloc","default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libbs58-9c1b527f667e9b67.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#regex@1.12.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-1.12.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"regex","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-1.12.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libregex-d96e94c4e477712b.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libtest2-harness@0.0.3","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libtest2-harness-0.0.3/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"libtest2_harness","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libtest2-harness-0.0.3/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["color","default","threads"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/liblibtest2_harness-0565a03be0c8ad21.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#anyhow@1.0.100","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anyhow-1.0.100/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"anyhow","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anyhow-1.0.100/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libanyhow-aa63d721d495c9ed.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#plotters@0.3.7","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/plotters-0.3.7/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"plotters","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/plotters-0.3.7/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["area_series","line_series","plotters-svg","svg_backend"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libplotters-6e935cc61655f4dc.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#criterion-plot@0.6.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/criterion-plot-0.6.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"criterion_plot","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/criterion-plot-0.6.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcriterion_plot-53e6659e2a02f287.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#walkdir@2.5.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/walkdir-2.5.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"walkdir","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/walkdir-2.5.0/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libwalkdir-ae2182fcdf4b005d.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#tinytemplate@1.2.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinytemplate-1.2.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"tinytemplate","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinytemplate-1.2.1/src/lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libtinytemplate-e29510c613283ea7.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ciborium@0.2.2","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ciborium-0.2.2/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ciborium","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ciborium-0.2.2/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libciborium-752b2f34559b301a.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#clap@4.5.53","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap-4.5.53/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"clap","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap-4.5.53/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["help","std"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libclap-1512d4912cd7344b.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rayon@1.11.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"rayon","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/librayon-f52660cf91085252.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#anes@0.1.6","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anes-0.1.6/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"anes","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anes-0.1.6/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libanes-c4bb1a46b1d0f431.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#cryptoxide@0.4.4","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cryptoxide-0.4.4/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"cryptoxide","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cryptoxide-0.4.4/src/lib.rs","edition":"2018","doc":true,"doctest":false,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["argon2","blake2","chacha","curve25519","default","digest","ed25519","hkdf","hmac","mac","pbkdf2","poly1305","ripemd160","salsa","scrypt","sha1","sha2","sha3","x25519"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcryptoxide-eb28ffc997656425.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#oorandom@11.1.5","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/oorandom-11.1.5/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"oorandom","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/oorandom-11.1.5/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/liboorandom-b44a1544b73e5712.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#ed25519-bip32@0.4.1","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ed25519-bip32-0.4.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ed25519_bip32","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ed25519-bip32-0.4.1/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libed25519_bip32-ed9b95cb46d17e96.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#criterion@0.7.0","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/criterion-0.7.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"criterion","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/criterion-0.7.0/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["cargo_bench_support","default","plotters","rayon"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcriterion-2d66dfaa76b7397d.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libtest2-mimic@0.0.4","manifest_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libtest2-mimic-0.0.4/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"libtest2_mimic","src_path":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libtest2-mimic-0.0.4/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["color","default","threads"],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/liblibtest2_mimic-b88259faa17f31b8.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/kes#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/kes/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"kes","src_path":"/Users/charles/Code/pallas-extras/kes/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libkes-26cb5f0dc05f2ea7.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/cbor-util#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/cbor-util/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"cbor_util","src_path":"/Users/charles/Code/pallas-extras/cbor-util/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"use of deprecated function `rand::thread_rng`: Renamed to `rng`","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"cbor-util/src/bounded_bytes.rs","byte_start":1913,"byte_end":1923,"line_start":71,"line_end":71,"column_start":29,"column_end":39,"is_primary":true,"text":[{"text":"        let mut rng = rand::thread_rng();","highlight_start":29,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(deprecated)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated function `rand::thread_rng`: Renamed to `rng`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mcbor-util/src/bounded_bytes.rs:71:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut rng = rand::thread_rng();\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(deprecated)]` on by default\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/cbor-util#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/cbor-util/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"cbor_util","src_path":"/Users/charles/Code/pallas-extras/cbor-util/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcbor_util-fd3b7a798525c92a.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/bip39#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/bip39/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bip39","src_path":"/Users/charles/Code/pallas-extras/bip39/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"manual implementation of `.is_multiple_of()`","code":{"code":"clippy::manual_is_multiple_of","explanation":null},"level":"warning","spans":[{"file_name":"bip39/src/lib.rs","byte_start":12725,"byte_end":12744,"line_start":373,"line_end":373,"column_start":34,"column_end":53,"is_primary":true,"text":[{"text":"    word_count < MIN_NB_WORDS || word_count % 3 != 0 || word_count > MAX_NB_WORDS","highlight_start":34,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/rust-1.92.0/index.html#manual_is_multiple_of","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::manual_is_multiple_of)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"replace with","code":null,"level":"help","spans":[{"file_name":"bip39/src/lib.rs","byte_start":12725,"byte_end":12744,"line_start":373,"line_end":373,"column_start":34,"column_end":53,"is_primary":true,"text":[{"text":"    word_count < MIN_NB_WORDS || word_count % 3 != 0 || word_count > MAX_NB_WORDS","highlight_start":34,"highlight_end":53}],"label":null,"suggested_replacement":"!word_count.is_multiple_of(3)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: manual implementation of `.is_multiple_of()`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mbip39/src/lib.rs:373:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m373\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     word_count < MIN_NB_WORDS || word_count % 3 != 0 || word_count > MAX_NB_WORDS\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: replace with: `!word_count.is_multiple_of(3)`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/rust-1.92.0/index.html#manual_is_multiple_of\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(clippy::manual_is_multiple_of)]` on by default\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/bip39#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/bip39/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bip39","src_path":"/Users/charles/Code/pallas-extras/bip39/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libbip39-754d30aa6273773f.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/bip39#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/bip39/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bip39","src_path":"/Users/charles/Code/pallas-extras/bip39/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"manual implementation of `.is_multiple_of()`","code":{"code":"clippy::manual_is_multiple_of","explanation":null},"level":"warning","spans":[{"file_name":"bip39/src/lib.rs","byte_start":12725,"byte_end":12744,"line_start":373,"line_end":373,"column_start":34,"column_end":53,"is_primary":true,"text":[{"text":"    word_count < MIN_NB_WORDS || word_count % 3 != 0 || word_count > MAX_NB_WORDS","highlight_start":34,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/rust-1.92.0/index.html#manual_is_multiple_of","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::manual_is_multiple_of)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"replace with","code":null,"level":"help","spans":[{"file_name":"bip39/src/lib.rs","byte_start":12725,"byte_end":12744,"line_start":373,"line_end":373,"column_start":34,"column_end":53,"is_primary":true,"text":[{"text":"    word_count < MIN_NB_WORDS || word_count % 3 != 0 || word_count > MAX_NB_WORDS","highlight_start":34,"highlight_end":53}],"label":null,"suggested_replacement":"!word_count.is_multiple_of(3)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: manual implementation of `.is_multiple_of()`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mbip39/src/lib.rs:373:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m373\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     word_count < MIN_NB_WORDS || word_count % 3 != 0 || word_count > MAX_NB_WORDS\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: replace with: `!word_count.is_multiple_of(3)`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/rust-1.92.0/index.html#manual_is_multiple_of\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(clippy::manual_is_multiple_of)]` on by default\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/bip39#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/bip39/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bip39","src_path":"/Users/charles/Code/pallas-extras/bip39/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libbip39-e0646c1b0f8bd072.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/database#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/database/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"database","src_path":"/Users/charles/Code/pallas-extras/database/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libdatabase-09b481fda2bc41bc.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/plutus#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/plutus/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"plutus","src_path":"/Users/charles/Code/pallas-extras/plutus/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libplutus-422d5c84bbad4665.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/bip32#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/bip32/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bip32","src_path":"/Users/charles/Code/pallas-extras/bip32/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libbip32-93af14d5ebbfe8d9.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/plutus#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/plutus/Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"conformance","src_path":"/Users/charles/Code/pallas-extras/plutus/tests/conformance.rs","edition":"2024","doc":false,"doctest":false,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libconformance-9d3bbfd379e0068a.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/bip32#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/bip32/Cargo.toml","target":{"kind":["bench"],"crate_types":["bin"],"name":"comparison","src_path":"/Users/charles/Code/pallas-extras/bip32/benches/comparison.rs","edition":"2024","doc":false,"doctest":false,"test":false},"message":{"$message_type":"diagnostic","message":"use of deprecated function `criterion::black_box`: use `std::hint::black_box()` instead","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"bip32/benches/comparison.rs","byte_start":81,"byte_end":90,"line_start":2,"line_end":2,"column_start":28,"column_end":37,"is_primary":true,"text":[{"text":"use criterion::{Criterion, black_box, criterion_group, criterion_main};","highlight_start":28,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(deprecated)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated function `criterion::black_box`: use `std::hint::black_box()` instead\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mbip32/benches/comparison.rs:2:28\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use criterion::{Criterion, black_box, criterion_group, criterion_main};\n  \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(deprecated)]` on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/bip32#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/bip32/Cargo.toml","target":{"kind":["bench"],"crate_types":["bin"],"name":"comparison","src_path":"/Users/charles/Code/pallas-extras/bip32/benches/comparison.rs","edition":"2024","doc":false,"doctest":false,"test":false},"message":{"$message_type":"diagnostic","message":"use of deprecated function `criterion::black_box`: use `std::hint::black_box()` instead","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"bip32/benches/comparison.rs","byte_start":572,"byte_end":581,"line_start":15,"line_end":15,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"            black_box(ours.derive_child(HardIndex::new(i)));","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated function `criterion::black_box`: use `std::hint::black_box()` instead\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mbip32/benches/comparison.rs:15:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             black_box(ours.derive_child(HardIndex::new(i)));\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/bip32#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/bip32/Cargo.toml","target":{"kind":["bench"],"crate_types":["bin"],"name":"comparison","src_path":"/Users/charles/Code/pallas-extras/bip32/benches/comparison.rs","edition":"2024","doc":false,"doctest":false,"test":false},"message":{"$message_type":"diagnostic","message":"use of deprecated function `criterion::black_box`: use `std::hint::black_box()` instead","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"bip32/benches/comparison.rs","byte_start":740,"byte_end":749,"line_start":20,"line_end":20,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"            black_box(baseline.derive(ed25519_bip32::DerivationScheme::V2, i | 0x80000000));","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated function `criterion::black_box`: use `std::hint::black_box()` instead\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mbip32/benches/comparison.rs:20:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             black_box(baseline.derive(ed25519_bip32::DerivationScheme::V2, i | 0x80000000));\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/bip32#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/bip32/Cargo.toml","target":{"kind":["bench"],"crate_types":["bin"],"name":"comparison","src_path":"/Users/charles/Code/pallas-extras/bip32/benches/comparison.rs","edition":"2024","doc":false,"doctest":false,"test":false},"message":{"$message_type":"diagnostic","message":"use of deprecated function `criterion::black_box`: use `std::hint::black_box()` instead","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"bip32/benches/comparison.rs","byte_start":1364,"byte_end":1373,"line_start":38,"line_end":38,"column_start":17,"column_end":26,"is_primary":true,"text":[{"text":"                black_box(ours.derive_child(SoftIndex::new(i)));","highlight_start":17,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated function `criterion::black_box`: use `std::hint::black_box()` instead\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mbip32/benches/comparison.rs:38:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 black_box(ours.derive_child(SoftIndex::new(i)));\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/bip32#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/bip32/Cargo.toml","target":{"kind":["bench"],"crate_types":["bin"],"name":"comparison","src_path":"/Users/charles/Code/pallas-extras/bip32/benches/comparison.rs","edition":"2024","doc":false,"doctest":false,"test":false},"message":{"$message_type":"diagnostic","message":"use of deprecated function `criterion::black_box`: use `std::hint::black_box()` instead","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"bip32/benches/comparison.rs","byte_start":1593,"byte_end":1602,"line_start":47,"line_end":47,"column_start":17,"column_end":26,"is_primary":true,"text":[{"text":"                black_box(","highlight_start":17,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated function `criterion::black_box`: use `std::hint::black_box()` instead\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mbip32/benches/comparison.rs:47:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 black_box(\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/bip32#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/bip32/Cargo.toml","target":{"kind":["bench"],"crate_types":["bin"],"name":"comparison","src_path":"/Users/charles/Code/pallas-extras/bip32/benches/comparison.rs","edition":"2024","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libcomparison-873a0d6a0d11a2e1.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"pallas-extras","src_path":"/Users/charles/Code/pallas-extras/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"constant `SKIPS` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":181,"byte_end":186,"line_start":7,"line_end":7,"column_start":7,"column_end":12,"is_primary":true,"text":[{"text":"const SKIPS: &[u16] = &[7779];","highlight_start":7,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: constant `SKIPS` is never used\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:7:7\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m const SKIPS: &[u16] = &[7779];\n  \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[33m^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"pallas-extras","src_path":"/Users/charles/Code/pallas-extras/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libpallas_extras-8f69e71f27ba1b9c.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"pallas-extras","src_path":"/Users/charles/Code/pallas-extras/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"constant `SKIPS` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":181,"byte_end":186,"line_start":7,"line_end":7,"column_start":7,"column_end":12,"is_primary":true,"text":[{"text":"const SKIPS: &[u16] = &[7779];","highlight_start":7,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: constant `SKIPS` is never used\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:7:7\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m const SKIPS: &[u16] = &[7779];\n  \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[33m^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"pallas-extras","src_path":"/Users/charles/Code/pallas-extras/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libpallas_extras-a79f5bc1c85f2164.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///Users/charles/Code/pallas-extras/database#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/database/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"database","src_path":"/Users/charles/Code/pallas-extras/database/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/Users/charles/Code/pallas-extras/target/debug/deps/libdatabase-5d14bfaf2faffbed.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unresolved import `digest::generic_array`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":12,"byte_end":25,"line_start":1,"line_end":1,"column_start":13,"column_end":26,"is_primary":true,"text":[{"text":"use digest::generic_array::GenericArray;","highlight_start":13,"highlight_end":26}],"label":"could not find `generic_array` in `digest`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0432]\u001b[0m\u001b[1m: unresolved import `digest::generic_array`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:1:13\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use digest::generic_array::GenericArray;\n  \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `generic_array` in `digest`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unresolved import `digest::generic_array`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":12,"byte_end":25,"line_start":1,"line_end":1,"column_start":13,"column_end":26,"is_primary":true,"text":[{"text":"use digest::generic_array::GenericArray;","highlight_start":13,"highlight_end":26}],"label":"could not find `generic_array` in `digest`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0432]\u001b[0m\u001b[1m: unresolved import `digest::generic_array`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:1:13\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use digest::generic_array::GenericArray;\n  \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `generic_array` in `digest`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Encode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":90,"byte_end":96,"line_start":2,"line_end":2,"column_start":68,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":68,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Encode` in this scope\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:2:68\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n  \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encode;\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Encode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":90,"byte_end":96,"line_start":2,"line_end":2,"column_start":68,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":68,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::Encode` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Encode` in this scope\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:2:68\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n  \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::Encode` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encode;\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Decode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":98,"byte_end":104,"line_start":2,"line_end":2,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":76,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Decode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Decode` in this scope\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:2:76\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n  \u001b[1m\u001b[94m|\u001b[0m                                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Decode;\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `CborLen` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":106,"byte_end":113,"line_start":2,"line_end":2,"column_start":84,"column_end":91,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":84,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::CborLen;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `CborLen` in this scope\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:2:84\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n  \u001b[1m\u001b[94m|\u001b[0m                                                                                    \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::CborLen;\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Decode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":98,"byte_end":104,"line_start":2,"line_end":2,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":76,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::Decode` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Decode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Decode` in this scope\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:2:76\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n  \u001b[1m\u001b[94m|\u001b[0m                                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::Decode` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Decode;\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `CborLen` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":106,"byte_end":113,"line_start":2,"line_end":2,"column_start":84,"column_end":91,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":84,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::CborLen` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::CborLen;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `CborLen` in this scope\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:2:84\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n  \u001b[1m\u001b[94m|\u001b[0m                                                                                    \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::CborLen` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::CborLen;\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":143,"byte_end":147,"line_start":4,"line_end":4,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[cbor(n(0), with = \"cbor_util::cbor_encoded\")]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:4:7\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m4\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[cbor(n(0), with = \"cbor_util::cbor_encoded\")]\n  \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":217,"byte_end":218,"line_start":6,"line_end":6,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(1)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:6:7\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(1)]\n  \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":143,"byte_end":147,"line_start":4,"line_end":4,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[cbor(n(0), with = \"cbor_util::cbor_encoded\")]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:4:7\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m4\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[cbor(n(0), with = \"cbor_util::cbor_encoded\")]\n  \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Encode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1835,"byte_end":1841,"line_start":53,"line_end":53,"column_start":68,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":68,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Encode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:53:68\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":217,"byte_end":218,"line_start":6,"line_end":6,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(1)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:6:7\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(1)]\n  \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Decode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1843,"byte_end":1849,"line_start":53,"line_end":53,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":76,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Decode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Decode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:53:76\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Decode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Encode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1835,"byte_end":1841,"line_start":53,"line_end":53,"column_start":68,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":68,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::Encode` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Encode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:53:68\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::Encode` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `CborLen` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1851,"byte_end":1858,"line_start":53,"line_end":53,"column_start":84,"column_end":91,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":84,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::CborLen;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `CborLen` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:53:84\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                                    \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::CborLen;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Decode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1843,"byte_end":1849,"line_start":53,"line_end":53,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":76,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::Decode` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Decode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Decode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:53:76\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::Decode` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Decode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `CborLen` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1851,"byte_end":1858,"line_start":53,"line_end":53,"column_start":84,"column_end":91,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":84,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::CborLen` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::CborLen;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `CborLen` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:53:84\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                                    \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::CborLen` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::CborLen;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1884,"byte_end":1888,"line_start":55,"line_end":55,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[cbor(n(0), with = \"minicbor::bytes\")]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:55:7\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[cbor(n(0), with = \"minicbor::bytes\")]\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1963,"byte_end":1964,"line_start":57,"line_end":57,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(1)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:57:7\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(1)]\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1884,"byte_end":1888,"line_start":55,"line_end":55,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[cbor(n(0), with = \"minicbor::bytes\")]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:55:7\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[cbor(n(0), with = \"minicbor::bytes\")]\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2003,"byte_end":2004,"line_start":59,"line_end":59,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(2)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:59:7\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(2)]\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1963,"byte_end":1964,"line_start":57,"line_end":57,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(1)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:57:7\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(1)]\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Encode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2240,"byte_end":2246,"line_start":69,"line_end":69,"column_start":68,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":68,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Encode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:69:68\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2003,"byte_end":2004,"line_start":59,"line_end":59,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(2)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:59:7\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(2)]\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Decode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2248,"byte_end":2254,"line_start":69,"line_end":69,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":76,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Decode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Decode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:69:76\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Decode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Encode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2240,"byte_end":2246,"line_start":69,"line_end":69,"column_start":68,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":68,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::Encode` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Encode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:69:68\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::Encode` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `CborLen` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2256,"byte_end":2263,"line_start":69,"line_end":69,"column_start":84,"column_end":91,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":84,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::CborLen;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `CborLen` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:69:84\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                                    \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::CborLen;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Decode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2248,"byte_end":2254,"line_start":69,"line_end":69,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":76,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::Decode` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Decode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Decode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:69:76\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::Decode` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Decode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `CborLen` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2256,"byte_end":2263,"line_start":69,"line_end":69,"column_start":84,"column_end":91,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":84,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::CborLen` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::CborLen;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `CborLen` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:69:84\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                                    \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::CborLen` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::CborLen;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2268,"byte_end":2272,"line_start":70,"line_end":70,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[cbor(flat)]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2280,"byte_end":2280,"line_start":71,"line_end":71,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum StakeDistribution {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:70:3\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[cbor(flat)]\n   \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum StakeDistribution {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2311,"byte_end":2312,"line_start":72,"line_end":72,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(1)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2280,"byte_end":2280,"line_start":71,"line_end":71,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum StakeDistribution {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:72:7\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(1)]\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum StakeDistribution {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2338,"byte_end":2339,"line_start":74,"line_end":74,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(0)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2280,"byte_end":2280,"line_start":71,"line_end":71,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum StakeDistribution {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:74:7\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(0)]\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum StakeDistribution {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2268,"byte_end":2272,"line_start":70,"line_end":70,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[cbor(flat)]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2280,"byte_end":2280,"line_start":71,"line_end":71,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum StakeDistribution {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:70:3\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[cbor(flat)]\n   \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum StakeDistribution {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2360,"byte_end":2364,"line_start":75,"line_end":75,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"    SingleKey(#[cbor(n(0), with = \"minicbor::bytes\")] Blake2b224Digest),","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2280,"byte_end":2280,"line_start":71,"line_end":71,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum StakeDistribution {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:75:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     SingleKey(#[cbor(n(0), with = \"minicbor::bytes\")] Blake2b224Digest),\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum StakeDistribution {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2311,"byte_end":2312,"line_start":72,"line_end":72,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(1)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2280,"byte_end":2280,"line_start":71,"line_end":71,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum StakeDistribution {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:72:7\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(1)]\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum StakeDistribution {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Encode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2487,"byte_end":2493,"line_start":78,"line_end":78,"column_start":68,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":68,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Encode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:78:68\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2338,"byte_end":2339,"line_start":74,"line_end":74,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(0)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2280,"byte_end":2280,"line_start":71,"line_end":71,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum StakeDistribution {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:74:7\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(0)]\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum StakeDistribution {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Decode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2495,"byte_end":2501,"line_start":78,"line_end":78,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":76,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Decode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Decode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:78:76\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Decode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2360,"byte_end":2364,"line_start":75,"line_end":75,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"    SingleKey(#[cbor(n(0), with = \"minicbor::bytes\")] Blake2b224Digest),","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2280,"byte_end":2280,"line_start":71,"line_end":71,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum StakeDistribution {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:75:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     SingleKey(#[cbor(n(0), with = \"minicbor::bytes\")] Blake2b224Digest),\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum StakeDistribution {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `CborLen` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2503,"byte_end":2510,"line_start":78,"line_end":78,"column_start":84,"column_end":91,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":84,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::CborLen;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `CborLen` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:78:84\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                                    \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::CborLen;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Encode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2487,"byte_end":2493,"line_start":78,"line_end":78,"column_start":68,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":68,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::Encode` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Encode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:78:68\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::Encode` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Decode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2495,"byte_end":2501,"line_start":78,"line_end":78,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":76,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::Decode` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Decode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Decode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:78:76\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::Decode` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Decode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `CborLen` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2503,"byte_end":2510,"line_start":78,"line_end":78,"column_start":84,"column_end":91,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":84,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::CborLen` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::CborLen;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `CborLen` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:78:84\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                                    \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::CborLen` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::CborLen;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2515,"byte_end":2519,"line_start":79,"line_end":79,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[cbor(transparent)]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2534,"byte_end":2534,"line_start":80,"line_end":80,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub struct AddressType(pub u32);","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:79:3\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[cbor(transparent)]\n   \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub struct AddressType(pub u32);\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Encode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2831,"byte_end":2837,"line_start":96,"line_end":96,"column_start":51,"column_end":57,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode, CborLen)]","highlight_start":51,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Encode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:96:51\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Decode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2839,"byte_end":2845,"line_start":96,"line_end":96,"column_start":59,"column_end":65,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode, CborLen)]","highlight_start":59,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Decode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Decode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:96:59\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Decode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2515,"byte_end":2519,"line_start":79,"line_end":79,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[cbor(transparent)]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2534,"byte_end":2534,"line_start":80,"line_end":80,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub struct AddressType(pub u32);","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:79:3\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[cbor(transparent)]\n   \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub struct AddressType(pub u32);\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `CborLen` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2847,"byte_end":2854,"line_start":96,"line_end":96,"column_start":67,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode, CborLen)]","highlight_start":67,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::CborLen;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `CborLen` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:96:67\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                   \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::CborLen;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Encode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2831,"byte_end":2837,"line_start":96,"line_end":96,"column_start":51,"column_end":57,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode, CborLen)]","highlight_start":51,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::Encode` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Encode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:96:51\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::Encode` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Decode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2839,"byte_end":2845,"line_start":96,"line_end":96,"column_start":59,"column_end":65,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode, CborLen)]","highlight_start":59,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::Decode` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Decode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Decode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:96:59\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::Decode` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Decode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `CborLen` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2847,"byte_end":2854,"line_start":96,"line_end":96,"column_start":67,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode, CborLen)]","highlight_start":67,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::CborLen` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::CborLen;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `CborLen` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:96:67\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                   \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::CborLen` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::CborLen;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2859,"byte_end":2863,"line_start":97,"line_end":97,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[cbor(flat)]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2871,"byte_end":2871,"line_start":98,"line_end":98,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum SpendingData {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:97:3\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m97\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[cbor(flat)]\n   \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum SpendingData {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2897,"byte_end":2898,"line_start":99,"line_end":99,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(0)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2871,"byte_end":2871,"line_start":98,"line_end":98,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum SpendingData {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:99:7\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(0)]\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum SpendingData {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2919,"byte_end":2920,"line_start":100,"line_end":100,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"    PublicKey(#[n(0)] ExtendedVerifyingKey),","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2871,"byte_end":2871,"line_start":98,"line_end":98,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum SpendingData {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:100:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m100\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PublicKey(#[n(0)] ExtendedVerifyingKey),\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m98\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n \u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum SpendingData {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2859,"byte_end":2863,"line_start":97,"line_end":97,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[cbor(flat)]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2871,"byte_end":2871,"line_start":98,"line_end":98,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum SpendingData {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:97:3\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m97\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[cbor(flat)]\n   \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum SpendingData {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2954,"byte_end":2955,"line_start":101,"line_end":101,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(1)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2871,"byte_end":2871,"line_start":98,"line_end":98,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum SpendingData {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:101:7\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m101\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(1)]\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m98\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n \u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum SpendingData {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2897,"byte_end":2898,"line_start":99,"line_end":99,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(0)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2871,"byte_end":2871,"line_start":98,"line_end":98,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum SpendingData {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:99:7\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(0)]\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum SpendingData {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2973,"byte_end":2977,"line_start":102,"line_end":102,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"    Redeem(#[cbor(n(0), with = \"minicbor::bytes\")] VerifyingKey),","highlight_start":14,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2871,"byte_end":2871,"line_start":98,"line_end":98,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum SpendingData {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:102:14\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m102\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Redeem(#[cbor(n(0), with = \"minicbor::bytes\")] VerifyingKey),\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m98\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n \u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum SpendingData {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2919,"byte_end":2920,"line_start":100,"line_end":100,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"    PublicKey(#[n(0)] ExtendedVerifyingKey),","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2871,"byte_end":2871,"line_start":98,"line_end":98,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum SpendingData {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:100:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m100\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PublicKey(#[n(0)] ExtendedVerifyingKey),\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m98\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n \u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum SpendingData {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Encode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3096,"byte_end":3102,"line_start":105,"line_end":105,"column_start":68,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":68,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Encode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:105:68\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m105\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encode;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2954,"byte_end":2955,"line_start":101,"line_end":101,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(1)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2871,"byte_end":2871,"line_start":98,"line_end":98,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum SpendingData {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:101:7\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m101\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(1)]\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m98\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n \u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum SpendingData {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Decode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3104,"byte_end":3110,"line_start":105,"line_end":105,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":76,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Decode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Decode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:105:76\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m105\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Decode;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2973,"byte_end":2977,"line_start":102,"line_end":102,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"    Redeem(#[cbor(n(0), with = \"minicbor::bytes\")] VerifyingKey),","highlight_start":14,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2871,"byte_end":2871,"line_start":98,"line_end":98,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum SpendingData {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:102:14\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m102\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Redeem(#[cbor(n(0), with = \"minicbor::bytes\")] VerifyingKey),\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m98\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n \u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m| \u001b[0menum SpendingData {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `CborLen` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3112,"byte_end":3119,"line_start":105,"line_end":105,"column_start":84,"column_end":91,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":84,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::CborLen;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `CborLen` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:105:84\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m105\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                    \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::CborLen;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Encode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3096,"byte_end":3102,"line_start":105,"line_end":105,"column_start":68,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":68,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::Encode` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Encode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:105:68\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m105\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::Encode` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encode;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `Decode` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3104,"byte_end":3110,"line_start":105,"line_end":105,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":76,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::Decode` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Decode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `Decode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:105:76\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m105\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::Decode` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Decode;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find derive macro `CborLen` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3112,"byte_end":3119,"line_start":105,"line_end":105,"column_start":84,"column_end":91,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":84,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"derive macro `crate::address::shelley::tests::CborLen` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this derive macro","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::CborLen;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find derive macro `CborLen` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:105:84\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m105\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                    \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: derive macro `crate::address::shelley::tests::CborLen` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this derive macro\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::CborLen;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3124,"byte_end":3128,"line_start":106,"line_end":106,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[cbor(map)]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3135,"byte_end":3135,"line_start":107,"line_end":107,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub struct Attributes {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:106:3\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[cbor(map)]\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m107\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m108\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub struct Attributes {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3165,"byte_end":3166,"line_start":108,"line_end":108,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(0)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:108:7\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m108\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(0)]\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3222,"byte_end":3226,"line_start":110,"line_end":110,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[cbor(n(2), with = \"cbor_no_tag\", has_nil)]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:110:7\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[cbor(n(2), with = \"cbor_no_tag\", has_nil)]\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3124,"byte_end":3128,"line_start":106,"line_end":106,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[cbor(map)]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3135,"byte_end":3135,"line_start":107,"line_end":107,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub struct Attributes {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(CborLen, Decode, Encode)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:106:3\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[cbor(map)]\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m107\u001b[0m \u001b[92m+ #[derive(CborLen, Decode, Encode)]\u001b[0m\n\u001b[1m\u001b[94m108\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub struct Attributes {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3372,"byte_end":3376,"line_start":113,"line_end":113,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[cbor(n(1), decode_with = \"fill_bytes\")]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:113:7\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[cbor(n(1), decode_with = \"fill_bytes\")]\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `n` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3165,"byte_end":3166,"line_start":108,"line_end":108,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    #[n(0)]","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `n` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:108:7\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m108\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[n(0)]\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `n` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3222,"byte_end":3226,"line_start":110,"line_end":110,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[cbor(n(2), with = \"cbor_no_tag\", has_nil)]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:110:7\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[cbor(n(2), with = \"cbor_no_tag\", has_nil)]\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `cbor` in this scope","code":null,"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3372,"byte_end":3376,"line_start":113,"line_end":113,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[cbor(n(1), decode_with = \"fill_bytes\")]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: cannot find attribute `cbor` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:113:7\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[cbor(n(1), decode_with = \"fill_bytes\")]\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `cbor` is an attribute that can be used by the derive macros `CborLen`, `Decode` and `Encode`, you might be missing a `derive` attribute\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: could not find `data` in `plutus`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":15627,"byte_end":15631,"line_start":431,"line_end":431,"column_start":66,"column_end":70,"is_primary":true,"text":[{"text":"    Data(#[cbor(n(0), with = \"cbor_util::cbor_encoded\")] plutus::data::Data),","highlight_start":66,"highlight_end":70}],"label":"could not find `data` in `plutus`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `data` in `plutus`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:431:66\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m431\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Data(#[cbor(n(0), with = \"cbor_util::cbor_encoded\")] plutus::data::Data),\n    \u001b[1m\u001b[94m|\u001b[0m                                                                  \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `data` in `plutus`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: could not find `data` in `plutus`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":15627,"byte_end":15631,"line_start":431,"line_end":431,"column_start":66,"column_end":70,"is_primary":true,"text":[{"text":"    Data(#[cbor(n(0), with = \"cbor_util::cbor_encoded\")] plutus::data::Data),","highlight_start":66,"highlight_end":70}],"label":"could not find `data` in `plutus`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `data` in `plutus`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:431:66\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m431\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Data(#[cbor(n(0), with = \"cbor_util::cbor_encoded\")] plutus::data::Data),\n    \u001b[1m\u001b[94m|\u001b[0m                                                                  \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `data` in `plutus`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Data` in module `plutus`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/witness.rs","byte_start":749,"byte_end":753,"line_start":27,"line_end":27,"column_start":35,"column_end":39,"is_primary":true,"text":[{"text":"    pub plutus_data: Box<[plutus::Data]>,","highlight_start":35,"highlight_end":39}],"label":"not found in `plutus`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use bip32::ExtendedVerifyingKey;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::transaction::Data;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Data`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":741,"byte_end":749,"line_start":27,"line_end":27,"column_start":27,"column_end":35,"is_primary":true,"text":[{"text":"    pub plutus_data: Box<[plutus::Data]>,","highlight_start":27,"highlight_end":35}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Data` in module `plutus`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/witness.rs:27:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub plutus_data: Box<[plutus::Data]>,\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `plutus`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::transaction::Data;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `Data`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[91m- \u001b[0m    pub plutus_data: Box<[\u001b[91mplutus::\u001b[0mData]>,\n\u001b[1m\u001b[94m27\u001b[0m \u001b[92m+ \u001b[0m    pub plutus_data: Box<[Data]>,\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Data` in module `plutus`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/witness.rs","byte_start":4852,"byte_end":4856,"line_start":157,"line_end":157,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"                    pub data: plutus::Data,","highlight_start":39,"highlight_end":43}],"label":"not found in `plutus`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use bip32::ExtendedVerifyingKey;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::transaction::Data;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Data`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":4844,"byte_end":4852,"line_start":157,"line_end":157,"column_start":31,"column_end":39,"is_primary":true,"text":[{"text":"                    pub data: plutus::Data,","highlight_start":31,"highlight_end":39}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Data` in module `plutus`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/witness.rs:157:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m157\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     pub data: plutus::Data,\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `plutus`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::transaction::Data;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `Data`, refer to it directly\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m157\u001b[0m \u001b[91m- \u001b[0m                    pub data: \u001b[91mplutus::\u001b[0mData,\n\u001b[1m\u001b[94m157\u001b[0m \u001b[92m+ \u001b[0m                    pub data: Data,\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Data` in module `plutus`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/witness.rs","byte_start":749,"byte_end":753,"line_start":27,"line_end":27,"column_start":35,"column_end":39,"is_primary":true,"text":[{"text":"    pub plutus_data: Box<[plutus::Data]>,","highlight_start":35,"highlight_end":39}],"label":"not found in `plutus`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use bip32::ExtendedVerifyingKey;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::transaction::Data;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Data`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":741,"byte_end":749,"line_start":27,"line_end":27,"column_start":27,"column_end":35,"is_primary":true,"text":[{"text":"    pub plutus_data: Box<[plutus::Data]>,","highlight_start":27,"highlight_end":35}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Data` in module `plutus`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/witness.rs:27:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub plutus_data: Box<[plutus::Data]>,\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `plutus`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::transaction::Data;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `Data`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[91m- \u001b[0m    pub plutus_data: Box<[\u001b[91mplutus::\u001b[0mData]>,\n\u001b[1m\u001b[94m27\u001b[0m \u001b[92m+ \u001b[0m    pub plutus_data: Box<[Data]>,\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Data` in module `plutus`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/witness.rs","byte_start":6184,"byte_end":6188,"line_start":193,"line_end":193,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"                    pub data: plutus::Data,","highlight_start":39,"highlight_end":43}],"label":"not found in `plutus`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use bip32::ExtendedVerifyingKey;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::transaction::Data;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Data`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":6176,"byte_end":6184,"line_start":193,"line_end":193,"column_start":31,"column_end":39,"is_primary":true,"text":[{"text":"                    pub data: plutus::Data,","highlight_start":31,"highlight_end":39}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Data` in module `plutus`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/witness.rs:193:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m193\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     pub data: plutus::Data,\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `plutus`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::transaction::Data;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `Data`, refer to it directly\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m193\u001b[0m \u001b[91m- \u001b[0m                    pub data: \u001b[91mplutus::\u001b[0mData,\n\u001b[1m\u001b[94m193\u001b[0m \u001b[92m+ \u001b[0m                    pub data: Data,\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Data` in module `plutus`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/witness.rs","byte_start":7917,"byte_end":7921,"line_start":248,"line_end":248,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"    pub data: plutus::Data,","highlight_start":23,"highlight_end":27}],"label":"not found in `plutus`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use bip32::ExtendedVerifyingKey;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::transaction::Data;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Data`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":7909,"byte_end":7917,"line_start":248,"line_end":248,"column_start":15,"column_end":23,"is_primary":true,"text":[{"text":"    pub data: plutus::Data,","highlight_start":15,"highlight_end":23}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Data` in module `plutus`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/witness.rs:248:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m248\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub data: plutus::Data,\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `plutus`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::transaction::Data;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `Data`, refer to it directly\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m248\u001b[0m \u001b[91m- \u001b[0m    pub data: \u001b[91mplutus::\u001b[0mData,\n\u001b[1m\u001b[94m248\u001b[0m \u001b[92m+ \u001b[0m    pub data: Data,\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Data` in module `plutus`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/witness.rs","byte_start":4852,"byte_end":4856,"line_start":157,"line_end":157,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"                    pub data: plutus::Data,","highlight_start":39,"highlight_end":43}],"label":"not found in `plutus`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use bip32::ExtendedVerifyingKey;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::transaction::Data;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Data`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":4844,"byte_end":4852,"line_start":157,"line_end":157,"column_start":31,"column_end":39,"is_primary":true,"text":[{"text":"                    pub data: plutus::Data,","highlight_start":31,"highlight_end":39}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Data` in module `plutus`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/witness.rs:157:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m157\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     pub data: plutus::Data,\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `plutus`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::transaction::Data;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `Data`, refer to it directly\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m157\u001b[0m \u001b[91m- \u001b[0m                    pub data: \u001b[91mplutus::\u001b[0mData,\n\u001b[1m\u001b[94m157\u001b[0m \u001b[92m+ \u001b[0m                    pub data: Data,\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Encoder`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":421,"byte_end":428,"line_start":13,"line_end":13,"column_start":32,"column_end":39,"is_primary":true,"text":[{"text":"        let mut root_encoder = Encoder::new(Vec::with_capacity(128));","highlight_start":32,"highlight_end":39}],"label":"use of undeclared type `Encoder`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use bech32::primitives::encode::Encoder;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encoder;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `Encoder`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:13:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut root_encoder = Encoder::new(Vec::with_capacity(128));\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Encoder`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use bech32::primitives::encode::Encoder;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encoder;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Blake2b224Digest` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":841,"byte_end":857,"line_start":26,"line_end":26,"column_start":26,"column_end":42,"is_primary":true,"text":[{"text":"        let root_digest: Blake2b224Digest =","highlight_start":26,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this type alias","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::crypto::Blake2b224Digest;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Blake2b224Digest` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:26:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let root_digest: Blake2b224Digest =\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this type alias\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::crypto::Blake2b224Digest;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Blake2b224`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":872,"byte_end":882,"line_start":27,"line_end":27,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":"            Blake2b224::digest(Sha3_256::digest(&root_bytes)).into();","highlight_start":13,"highlight_end":23}],"label":"use of undeclared type `Blake2b224`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this type alias","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::crypto::Blake2b224;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `Blake2b224`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:27:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             Blake2b224::digest(Sha3_256::digest(&root_bytes)).into();\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Blake2b224`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this type alias\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::crypto::Blake2b224;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Data` in module `plutus`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/witness.rs","byte_start":6184,"byte_end":6188,"line_start":193,"line_end":193,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"                    pub data: plutus::Data,","highlight_start":39,"highlight_end":43}],"label":"not found in `plutus`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use bip32::ExtendedVerifyingKey;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::transaction::Data;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Data`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":6176,"byte_end":6184,"line_start":193,"line_end":193,"column_start":31,"column_end":39,"is_primary":true,"text":[{"text":"                    pub data: plutus::Data,","highlight_start":31,"highlight_end":39}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Data` in module `plutus`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/witness.rs:193:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m193\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     pub data: plutus::Data,\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `plutus`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::transaction::Data;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `Data`, refer to it directly\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m193\u001b[0m \u001b[91m- \u001b[0m                    pub data: \u001b[91mplutus::\u001b[0mData,\n\u001b[1m\u001b[94m193\u001b[0m \u001b[92m+ \u001b[0m                    pub data: Data,\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Sha3_256`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":891,"byte_end":899,"line_start":27,"line_end":27,"column_start":32,"column_end":40,"is_primary":true,"text":[{"text":"            Blake2b224::digest(Sha3_256::digest(&root_bytes)).into();","highlight_start":32,"highlight_end":40}],"label":"use of undeclared type `Sha3_256`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sha3::Sha3_256;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `Sha3_256`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:27:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             Blake2b224::digest(Sha3_256::digest(&root_bytes)).into();\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Sha3_256`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use sha3::Sha3_256;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Blake2b224Digest` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1939,"byte_end":1955,"line_start":56,"line_end":56,"column_start":18,"column_end":34,"is_primary":true,"text":[{"text":"    root_digest: Blake2b224Digest,","highlight_start":18,"highlight_end":34}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this type alias","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::crypto::Blake2b224Digest;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Blake2b224Digest` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:56:18\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m56\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     root_digest: Blake2b224Digest,\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this type alias\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::crypto::Blake2b224Digest;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Blake2b224Digest` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2398,"byte_end":2414,"line_start":75,"line_end":75,"column_start":55,"column_end":71,"is_primary":true,"text":[{"text":"    SingleKey(#[cbor(n(0), with = \"minicbor::bytes\")] Blake2b224Digest),","highlight_start":55,"highlight_end":71}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this type alias","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::crypto::Blake2b224Digest;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Blake2b224Digest` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:75:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     SingleKey(#[cbor(n(0), with = \"minicbor::bytes\")] Blake2b224Digest),\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this type alias\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::crypto::Blake2b224Digest;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Data` in module `plutus`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/witness.rs","byte_start":7917,"byte_end":7921,"line_start":248,"line_end":248,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"    pub data: plutus::Data,","highlight_start":23,"highlight_end":27}],"label":"not found in `plutus`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use bip32::ExtendedVerifyingKey;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::transaction::Data;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Data`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"ledger/src/witness.rs","byte_start":7909,"byte_end":7917,"line_start":248,"line_end":248,"column_start":15,"column_end":23,"is_primary":true,"text":[{"text":"    pub data: plutus::Data,","highlight_start":15,"highlight_end":23}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Data` in module `plutus`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/witness.rs:248:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m248\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub data: plutus::Data,\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `plutus`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::transaction::Data;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `Data`, refer to it directly\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m248\u001b[0m \u001b[91m- \u001b[0m    pub data: \u001b[91mplutus::\u001b[0mData,\n\u001b[1m\u001b[94m248\u001b[0m \u001b[92m+ \u001b[0m    pub data: Data,\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Encoder`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":421,"byte_end":428,"line_start":13,"line_end":13,"column_start":32,"column_end":39,"is_primary":true,"text":[{"text":"        let mut root_encoder = Encoder::new(Vec::with_capacity(128));","highlight_start":32,"highlight_end":39}],"label":"use of undeclared type `Encoder`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"struct `crate::address::byron::tests::Encoder` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use bech32::primitives::encode::Encoder;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::Encoder;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `Encoder`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:13:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut root_encoder = Encoder::new(Vec::with_capacity(128));\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Encoder`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: struct `crate::address::byron::tests::Encoder` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use bech32::primitives::encode::Encoder;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::Encoder;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `ExtendedVerifyingKey` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2925,"byte_end":2945,"line_start":100,"line_end":100,"column_start":23,"column_end":43,"is_primary":true,"text":[{"text":"    PublicKey(#[n(0)] ExtendedVerifyingKey),","highlight_start":23,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use bip32::ExtendedVerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtendedVerifyingKey` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:100:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m100\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PublicKey(#[n(0)] ExtendedVerifyingKey),\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use bip32::ExtendedVerifyingKey;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Blake2b224Digest` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":841,"byte_end":857,"line_start":26,"line_end":26,"column_start":26,"column_end":42,"is_primary":true,"text":[{"text":"        let root_digest: Blake2b224Digest =","highlight_start":26,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this type alias","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::crypto::Blake2b224Digest;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Blake2b224Digest` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:26:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let root_digest: Blake2b224Digest =\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this type alias\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::crypto::Blake2b224Digest;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `VerifyingKey` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3011,"byte_end":3023,"line_start":102,"line_end":102,"column_start":52,"column_end":64,"is_primary":true,"text":[{"text":"    Redeem(#[cbor(n(0), with = \"minicbor::bytes\")] VerifyingKey),","highlight_start":52,"highlight_end":64}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::crypto::VerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::crypto::kes::VerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::witness::VerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use ed25519_dalek::VerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use kes::single_use::VerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use kes::sum::VerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `VerifyingKey` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:102:52\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m102\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Redeem(#[cbor(n(0), with = \"minicbor::bytes\")] VerifyingKey),\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::crypto::VerifyingKey;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::crypto::kes::VerifyingKey;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::witness::VerifyingKey;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use ed25519_dalek::VerifyingKey;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0mand 2 other candidates\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Blake2b224`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":872,"byte_end":882,"line_start":27,"line_end":27,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":"            Blake2b224::digest(Sha3_256::digest(&root_bytes)).into();","highlight_start":13,"highlight_end":23}],"label":"use of undeclared type `Blake2b224`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this type alias","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::crypto::Blake2b224;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `Blake2b224`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:27:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             Blake2b224::digest(Sha3_256::digest(&root_bytes)).into();\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Blake2b224`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this type alias\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::crypto::Blake2b224;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Sha3_256`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":891,"byte_end":899,"line_start":27,"line_end":27,"column_start":32,"column_end":40,"is_primary":true,"text":[{"text":"            Blake2b224::digest(Sha3_256::digest(&root_bytes)).into();","highlight_start":32,"highlight_end":40}],"label":"use of undeclared type `Sha3_256`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"struct `crate::address::byron::tests::Sha3_256` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sha3::Sha3_256;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `Sha3_256`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:27:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             Blake2b224::digest(Sha3_256::digest(&root_bytes)).into();\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Sha3_256`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: struct `crate::address::byron::tests::Sha3_256` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use sha3::Sha3_256;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Blake2b224Digest` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1939,"byte_end":1955,"line_start":56,"line_end":56,"column_start":18,"column_end":34,"is_primary":true,"text":[{"text":"    root_digest: Blake2b224Digest,","highlight_start":18,"highlight_end":34}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this type alias","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::crypto::Blake2b224Digest;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Blake2b224Digest` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:56:18\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m56\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     root_digest: Blake2b224Digest,\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this type alias\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::crypto::Blake2b224Digest;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `ByteArray` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3445,"byte_end":3454,"line_start":114,"line_end":114,"column_start":34,"column_end":43,"is_primary":true,"text":[{"text":"    _key_derivation_path: Option<ByteArray<30>>,","highlight_start":34,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::bytes::ByteArray;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ByteArray` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:114:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m114\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _key_derivation_path: Option<ByteArray<30>>,\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::bytes::ByteArray;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Blake2b224Digest` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2398,"byte_end":2414,"line_start":75,"line_end":75,"column_start":55,"column_end":71,"is_primary":true,"text":[{"text":"    SingleKey(#[cbor(n(0), with = \"minicbor::bytes\")] Blake2b224Digest),","highlight_start":55,"highlight_end":71}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this type alias","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::crypto::Blake2b224Digest;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `Blake2b224Digest` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:75:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     SingleKey(#[cbor(n(0), with = \"minicbor::bytes\")] Blake2b224Digest),\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this type alias\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::crypto::Blake2b224Digest;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `ByteArray` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":5247,"byte_end":5256,"line_start":183,"line_end":183,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":") -> Result<Option<ByteArray<30>>, minicbor::decode::Error> {","highlight_start":20,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::bytes::ByteArray;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ByteArray` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:183:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m183\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Option<ByteArray<30>>, minicbor::decode::Error> {\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::bytes::ByteArray;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `ExtendedVerifyingKey` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":2925,"byte_end":2945,"line_start":100,"line_end":100,"column_start":23,"column_end":43,"is_primary":true,"text":[{"text":"    PublicKey(#[n(0)] ExtendedVerifyingKey),","highlight_start":23,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"struct `crate::address::byron::tests::ExtendedVerifyingKey` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use bip32::ExtendedVerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtendedVerifyingKey` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:100:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m100\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PublicKey(#[n(0)] ExtendedVerifyingKey),\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: struct `crate::address::byron::tests::ExtendedVerifyingKey` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use bip32::ExtendedVerifyingKey;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `VerifyingKey` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3011,"byte_end":3023,"line_start":102,"line_end":102,"column_start":52,"column_end":64,"is_primary":true,"text":[{"text":"    Redeem(#[cbor(n(0), with = \"minicbor::bytes\")] VerifyingKey),","highlight_start":52,"highlight_end":64}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::crypto::VerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::crypto::kes::VerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::witness::VerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use ed25519_dalek::VerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use kes::single_use::VerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use kes::sum::VerifyingKey;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `VerifyingKey` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:102:52\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m102\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Redeem(#[cbor(n(0), with = \"minicbor::bytes\")] VerifyingKey),\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::crypto::VerifyingKey;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::crypto::kes::VerifyingKey;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crate::witness::VerifyingKey;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use ed25519_dalek::VerifyingKey;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0mand 2 other candidates\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `ByteArray` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":3445,"byte_end":3454,"line_start":114,"line_end":114,"column_start":34,"column_end":43,"is_primary":true,"text":[{"text":"    _key_derivation_path: Option<ByteArray<30>>,","highlight_start":34,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"struct `crate::address::byron::tests::ByteArray` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::bytes::ByteArray;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ByteArray` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:114:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m114\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _key_derivation_path: Option<ByteArray<30>>,\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: struct `crate::address::byron::tests::ByteArray` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::bytes::ByteArray;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `ByteArray` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":5247,"byte_end":5256,"line_start":183,"line_end":183,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":") -> Result<Option<ByteArray<30>>, minicbor::decode::Error> {","highlight_start":20,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"struct `crate::address::byron::tests::ByteArray` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"/// Byron Era address.","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use minicbor::bytes::ByteArray;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ByteArray` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:183:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m183\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Option<ByteArray<30>>, minicbor::decode::Error> {\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: struct `crate::address::byron::tests::ByteArray` exists but is inaccessible\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use minicbor::bytes::ByteArray;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":427,"byte_end":449,"line_start":21,"line_end":21,"column_start":20,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":20,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":427,"byte_end":449,"line_start":21,"line_end":21,"column_start":20,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":20,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":427,"byte_end":449,"line_start":21,"line_end":21,"column_start":20,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":20,"highlight_end":42}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":427,"byte_end":449,"line_start":21,"line_end":21,"column_start":20,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":20,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":427,"byte_end":449,"line_start":21,"line_end":21,"column_start":20,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":20,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":427,"byte_end":449,"line_start":21,"line_end":21,"column_start":20,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":20,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":427,"byte_end":449,"line_start":21,"line_end":21,"column_start":20,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":20,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":427,"byte_end":449,"line_start":21,"line_end":21,"column_start":20,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":20,"highlight_end":42}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":427,"byte_end":449,"line_start":21,"line_end":21,"column_start":20,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":20,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":427,"byte_end":449,"line_start":21,"line_end":21,"column_start":20,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":20,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::marker::StructuralPartialEq`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs","byte_start":10182,"byte_end":10229,"line_start":261,"line_end":263,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait StructuralPartialEq {","highlight_start":1,"highlight_end":32},{"text":"    // Empty.","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `StructuralPartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::marker::StructuralPartialEq`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs:261:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait StructuralPartialEq {\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     // Empty.\n\u001b[1m\u001b[94m263\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `StructuralPartialEq`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::marker::StructuralPartialEq`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs","byte_start":10182,"byte_end":10229,"line_start":261,"line_end":263,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait StructuralPartialEq {","highlight_start":1,"highlight_end":32},{"text":"    // Empty.","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `StructuralPartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::marker::StructuralPartialEq`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs:261:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait StructuralPartialEq {\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     // Empty.\n\u001b[1m\u001b[94m263\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `StructuralPartialEq`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::marker::StructuralPartialEq`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs","byte_start":10182,"byte_end":10229,"line_start":261,"line_end":263,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait StructuralPartialEq {","highlight_start":1,"highlight_end":32},{"text":"    // Empty.","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `StructuralPartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::marker::StructuralPartialEq`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs:261:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait StructuralPartialEq {\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     // Empty.\n\u001b[1m\u001b[94m263\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `StructuralPartialEq`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::marker::StructuralPartialEq`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs","byte_start":10182,"byte_end":10229,"line_start":261,"line_end":263,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait StructuralPartialEq {","highlight_start":1,"highlight_end":32},{"text":"    // Empty.","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `StructuralPartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::marker::StructuralPartialEq`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs:261:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait StructuralPartialEq {\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     // Empty.\n\u001b[1m\u001b[94m263\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `StructuralPartialEq`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::marker::StructuralPartialEq`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs","byte_start":10182,"byte_end":10229,"line_start":261,"line_end":263,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait StructuralPartialEq {","highlight_start":1,"highlight_end":32},{"text":"    // Empty.","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `StructuralPartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::marker::StructuralPartialEq`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs:261:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait StructuralPartialEq {\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     // Empty.\n\u001b[1m\u001b[94m263\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `StructuralPartialEq`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::marker::StructuralPartialEq`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs","byte_start":10182,"byte_end":10229,"line_start":261,"line_end":263,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait StructuralPartialEq {","highlight_start":1,"highlight_end":32},{"text":"    // Empty.","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `StructuralPartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::marker::StructuralPartialEq`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs:261:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait StructuralPartialEq {\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     // Empty.\n\u001b[1m\u001b[94m263\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `StructuralPartialEq`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::marker::StructuralPartialEq`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs","byte_start":10182,"byte_end":10229,"line_start":261,"line_end":263,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait StructuralPartialEq {","highlight_start":1,"highlight_end":32},{"text":"    // Empty.","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `StructuralPartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::marker::StructuralPartialEq`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs:261:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait StructuralPartialEq {\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     // Empty.\n\u001b[1m\u001b[94m263\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `StructuralPartialEq`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::marker::StructuralPartialEq`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs","byte_start":10182,"byte_end":10229,"line_start":261,"line_end":263,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait StructuralPartialEq {","highlight_start":1,"highlight_end":32},{"text":"    // Empty.","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `StructuralPartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::marker::StructuralPartialEq`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs:261:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait StructuralPartialEq {\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     // Empty.\n\u001b[1m\u001b[94m263\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `StructuralPartialEq`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::marker::StructuralPartialEq`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs","byte_start":10182,"byte_end":10229,"line_start":261,"line_end":263,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait StructuralPartialEq {","highlight_start":1,"highlight_end":32},{"text":"    // Empty.","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `StructuralPartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::marker::StructuralPartialEq`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs:261:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait StructuralPartialEq {\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     // Empty.\n\u001b[1m\u001b[94m263\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `StructuralPartialEq`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::marker::StructuralPartialEq`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs","byte_start":10182,"byte_end":10229,"line_start":261,"line_end":263,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait StructuralPartialEq {","highlight_start":1,"highlight_end":32},{"text":"    // Empty.","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `StructuralPartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::marker::StructuralPartialEq`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs:261:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait StructuralPartialEq {\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     // Empty.\n\u001b[1m\u001b[94m263\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `StructuralPartialEq`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::result::Result`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":21237,"byte_end":21238,"line_start":557,"line_end":557,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Result<T, E> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::result::Result`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:557:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m557\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Result<T, E> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Result`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::result::Result`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":21237,"byte_end":21238,"line_start":557,"line_end":557,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Result<T, E> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::result::Result`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:557:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m557\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Result<T, E> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Result`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::result::Result`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":21237,"byte_end":21238,"line_start":557,"line_end":557,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Result<T, E> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::result::Result`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:557:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m557\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Result<T, E> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Result`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::result::Result`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":21237,"byte_end":21238,"line_start":557,"line_end":557,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Result<T, E> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::result::Result`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:557:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m557\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Result<T, E> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Result`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::result::Result`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":21237,"byte_end":21238,"line_start":557,"line_end":557,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Result<T, E> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::result::Result`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:557:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m557\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Result<T, E> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Result`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::result::Result`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":21237,"byte_end":21238,"line_start":557,"line_end":557,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Result<T, E> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::result::Result`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:557:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m557\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Result<T, E> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Result`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::result::Result`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":21237,"byte_end":21238,"line_start":557,"line_end":557,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Result<T, E> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::result::Result`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:557:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m557\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Result<T, E> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Result`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs","byte_start":697,"byte_end":702,"line_start":28,"line_end":28,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"pub trait Decode<'b, C>: Sized {","highlight_start":26,"highlight_end":31}],"label":"required by this bound in `Decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs:28:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Decode<'b, C>: Sized {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::result::Result`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":21237,"byte_end":21238,"line_start":557,"line_end":557,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Result<T, E> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::result::Result`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:557:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m557\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Result<T, E> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Result`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::result::Result`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":21237,"byte_end":21238,"line_start":557,"line_end":557,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Result<T, E> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::result::Result`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:557:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m557\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Result<T, E> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Result`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs","byte_start":697,"byte_end":702,"line_start":28,"line_end":28,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"pub trait Decode<'b, C>: Sized {","highlight_start":26,"highlight_end":31}],"label":"required by this bound in `Decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs:28:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Decode<'b, C>: Sized {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::result::Result`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":21237,"byte_end":21238,"line_start":557,"line_end":557,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Result<T, E> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::result::Result`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:557:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m557\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Result<T, E> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Result`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs","byte_start":697,"byte_end":702,"line_start":28,"line_end":28,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"pub trait Decode<'b, C>: Sized {","highlight_start":26,"highlight_end":31}],"label":"required by this bound in `Decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs:28:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Decode<'b, C>: Sized {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs","byte_start":697,"byte_end":702,"line_start":28,"line_end":28,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"pub trait Decode<'b, C>: Sized {","highlight_start":26,"highlight_end":31}],"label":"required by this bound in `Decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs:28:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Decode<'b, C>: Sized {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs","byte_start":697,"byte_end":702,"line_start":28,"line_end":28,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"pub trait Decode<'b, C>: Sized {","highlight_start":26,"highlight_end":31}],"label":"required by this bound in `Decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs:28:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Decode<'b, C>: Sized {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs","byte_start":697,"byte_end":702,"line_start":28,"line_end":28,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"pub trait Decode<'b, C>: Sized {","highlight_start":26,"highlight_end":31}],"label":"required by this bound in `Decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs:28:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Decode<'b, C>: Sized {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs","byte_start":697,"byte_end":702,"line_start":28,"line_end":28,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"pub trait Decode<'b, C>: Sized {","highlight_start":26,"highlight_end":31}],"label":"required by this bound in `Decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs:28:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Decode<'b, C>: Sized {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::CborLen`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":1998,"byte_end":2133,"line_start":52,"line_end":55,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait CborLen<C> {","highlight_start":1,"highlight_end":23},{"text":"    /// Compute the CBOR encoding length in bytes of this value.","highlight_start":1,"highlight_end":65},{"text":"    fn cbor_len(&self, ctx: &mut C) -> usize;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `CborLen`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::CborLen`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:52:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CborLen<C> {\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Compute the CBOR encoding length in bytes of this value.\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     fn cbor_len(&self, ctx: &mut C) -> usize;\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `CborLen`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs","byte_start":697,"byte_end":702,"line_start":28,"line_end":28,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"pub trait Decode<'b, C>: Sized {","highlight_start":26,"highlight_end":31}],"label":"required by this bound in `Decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs:28:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Decode<'b, C>: Sized {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs","byte_start":697,"byte_end":702,"line_start":28,"line_end":28,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"pub trait Decode<'b, C>: Sized {","highlight_start":26,"highlight_end":31}],"label":"required by this bound in `Decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs:28:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Decode<'b, C>: Sized {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::CborLen`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":1998,"byte_end":2133,"line_start":52,"line_end":55,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait CborLen<C> {","highlight_start":1,"highlight_end":23},{"text":"    /// Compute the CBOR encoding length in bytes of this value.","highlight_start":1,"highlight_end":65},{"text":"    fn cbor_len(&self, ctx: &mut C) -> usize;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `CborLen`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::CborLen`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:52:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CborLen<C> {\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Compute the CBOR encoding length in bytes of this value.\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     fn cbor_len(&self, ctx: &mut C) -> usize;\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `CborLen`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs","byte_start":697,"byte_end":702,"line_start":28,"line_end":28,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"pub trait Decode<'b, C>: Sized {","highlight_start":26,"highlight_end":31}],"label":"required by this bound in `Decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode.rs:28:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Decode<'b, C>: Sized {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::CborLen`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":1998,"byte_end":2133,"line_start":52,"line_end":55,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait CborLen<C> {","highlight_start":1,"highlight_end":23},{"text":"    /// Compute the CBOR encoding length in bytes of this value.","highlight_start":1,"highlight_end":65},{"text":"    fn cbor_len(&self, ctx: &mut C) -> usize;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `CborLen`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::CborLen`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:52:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CborLen<C> {\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Compute the CBOR encoding length in bytes of this value.\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     fn cbor_len(&self, ctx: &mut C) -> usize;\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `CborLen`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::CborLen`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":1998,"byte_end":2133,"line_start":52,"line_end":55,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait CborLen<C> {","highlight_start":1,"highlight_end":23},{"text":"    /// Compute the CBOR encoding length in bytes of this value.","highlight_start":1,"highlight_end":65},{"text":"    fn cbor_len(&self, ctx: &mut C) -> usize;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `CborLen`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::CborLen`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:52:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CborLen<C> {\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Compute the CBOR encoding length in bytes of this value.\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     fn cbor_len(&self, ctx: &mut C) -> usize;\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `CborLen`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::CborLen`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":1998,"byte_end":2133,"line_start":52,"line_end":55,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait CborLen<C> {","highlight_start":1,"highlight_end":23},{"text":"    /// Compute the CBOR encoding length in bytes of this value.","highlight_start":1,"highlight_end":65},{"text":"    fn cbor_len(&self, ctx: &mut C) -> usize;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `CborLen`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::CborLen`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:52:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CborLen<C> {\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Compute the CBOR encoding length in bytes of this value.\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     fn cbor_len(&self, ctx: &mut C) -> usize;\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `CborLen`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::CborLen`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":1998,"byte_end":2133,"line_start":52,"line_end":55,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait CborLen<C> {","highlight_start":1,"highlight_end":23},{"text":"    /// Compute the CBOR encoding length in bytes of this value.","highlight_start":1,"highlight_end":65},{"text":"    fn cbor_len(&self, ctx: &mut C) -> usize;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `CborLen`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::CborLen`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:52:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CborLen<C> {\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Compute the CBOR encoding length in bytes of this value.\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     fn cbor_len(&self, ctx: &mut C) -> usize;\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `CborLen`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::CborLen`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":1998,"byte_end":2133,"line_start":52,"line_end":55,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait CborLen<C> {","highlight_start":1,"highlight_end":23},{"text":"    /// Compute the CBOR encoding length in bytes of this value.","highlight_start":1,"highlight_end":65},{"text":"    fn cbor_len(&self, ctx: &mut C) -> usize;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `CborLen`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::CborLen`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:52:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CborLen<C> {\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Compute the CBOR encoding length in bytes of this value.\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     fn cbor_len(&self, ctx: &mut C) -> usize;\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `CborLen`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::CborLen`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":1998,"byte_end":2133,"line_start":52,"line_end":55,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait CborLen<C> {","highlight_start":1,"highlight_end":23},{"text":"    /// Compute the CBOR encoding length in bytes of this value.","highlight_start":1,"highlight_end":65},{"text":"    fn cbor_len(&self, ctx: &mut C) -> usize;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `CborLen`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::CborLen`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:52:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CborLen<C> {\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Compute the CBOR encoding length in bytes of this value.\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     fn cbor_len(&self, ctx: &mut C) -> usize;\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `CborLen`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":236,"line_start":11,"line_end":11,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"only the last field of a struct may have a dynamically sized type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"change the field's type to have a statically known size","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"borrowed types always have a statically known size","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"the `Box` type always has a statically known size and allocates its contents in the heap","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"ledger/src/block.rs","byte_start":236,"byte_end":236,"line_start":11,"line_end":11,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":">","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: only the last field of a struct may have a dynamically sized type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: change the field's type to have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: borrowed types always have a statically known size\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92m&\u001b[0mHeader,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the `Box` type always has a statically known size and allocates its contents in the heap\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92mBox<\u001b[0mHeader\u001b[92m>\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++\u001b[0m      \u001b[92m+\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::CborLen`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":1998,"byte_end":2133,"line_start":52,"line_end":55,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait CborLen<C> {","highlight_start":1,"highlight_end":23},{"text":"    /// Compute the CBOR encoding length in bytes of this value.","highlight_start":1,"highlight_end":65},{"text":"    fn cbor_len(&self, ctx: &mut C) -> usize;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `CborLen`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::CborLen`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:52:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CborLen<C> {\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Compute the CBOR encoding length in bytes of this value.\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     fn cbor_len(&self, ctx: &mut C) -> usize;\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `CborLen`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::CborLen`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":1998,"byte_end":2133,"line_start":52,"line_end":55,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait CborLen<C> {","highlight_start":1,"highlight_end":23},{"text":"    /// Compute the CBOR encoding length in bytes of this value.","highlight_start":1,"highlight_end":65},{"text":"    fn cbor_len(&self, ctx: &mut C) -> usize;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `CborLen`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::CborLen`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:52:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CborLen<C> {\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Compute the CBOR encoding length in bytes of this value.\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     fn cbor_len(&self, ctx: &mut C) -> usize;\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `CborLen`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":236,"line_start":11,"line_end":11,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"only the last field of a struct may have a dynamically sized type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"change the field's type to have a statically known size","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"borrowed types always have a statically known size","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"the `Box` type always has a statically known size and allocates its contents in the heap","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"ledger/src/block.rs","byte_start":236,"byte_end":236,"line_start":11,"line_end":11,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":">","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: only the last field of a struct may have a dynamically sized type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: change the field's type to have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: borrowed types always have a statically known size\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92m&\u001b[0mHeader,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the `Box` type always has a statically known size and allocates its contents in the heap\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92mBox<\u001b[0mHeader\u001b[92m>\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++\u001b[0m      \u001b[92m+\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":236,"line_start":11,"line_end":11,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":23}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"only the last field of a struct may have a dynamically sized type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"change the field's type to have a statically known size","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"borrowed types always have a statically known size","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"the `Box` type always has a statically known size and allocates its contents in the heap","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"ledger/src/block.rs","byte_start":236,"byte_end":236,"line_start":11,"line_end":11,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":">","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: only the last field of a struct may have a dynamically sized type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: change the field's type to have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: borrowed types always have a statically known size\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92m&\u001b[0mHeader,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the `Box` type always has a statically known size and allocates its contents in the heap\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92mBox<\u001b[0mHeader\u001b[92m>\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++\u001b[0m      \u001b[92m+\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":236,"line_start":11,"line_end":11,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"only the last field of a struct may have a dynamically sized type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"change the field's type to have a statically known size","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"borrowed types always have a statically known size","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"the `Box` type always has a statically known size and allocates its contents in the heap","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"ledger/src/block.rs","byte_start":236,"byte_end":236,"line_start":11,"line_end":11,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":">","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: only the last field of a struct may have a dynamically sized type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: change the field's type to have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: borrowed types always have a statically known size\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92m&\u001b[0mHeader,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the `Box` type always has a statically known size and allocates its contents in the heap\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92mBox<\u001b[0mHeader\u001b[92m>\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++\u001b[0m      \u001b[92m+\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":236,"line_start":11,"line_end":11,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"only the last field of a struct may have a dynamically sized type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"change the field's type to have a statically known size","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"borrowed types always have a statically known size","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"the `Box` type always has a statically known size and allocates its contents in the heap","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"ledger/src/block.rs","byte_start":236,"byte_end":236,"line_start":11,"line_end":11,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":">","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: only the last field of a struct may have a dynamically sized type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: change the field's type to have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: borrowed types always have a statically known size\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92m&\u001b[0mHeader,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the `Box` type always has a statically known size and allocates its contents in the heap\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92mBox<\u001b[0mHeader\u001b[92m>\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++\u001b[0m      \u001b[92m+\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":236,"line_start":11,"line_end":11,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"only the last field of a struct may have a dynamically sized type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"change the field's type to have a statically known size","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"borrowed types always have a statically known size","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"the `Box` type always has a statically known size and allocates its contents in the heap","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"ledger/src/block.rs","byte_start":236,"byte_end":236,"line_start":11,"line_end":11,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":">","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: only the last field of a struct may have a dynamically sized type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: change the field's type to have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: borrowed types always have a statically known size\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92m&\u001b[0mHeader,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the `Box` type always has a statically known size and allocates its contents in the heap\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92mBox<\u001b[0mHeader\u001b[92m>\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++\u001b[0m      \u001b[92m+\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":236,"line_start":11,"line_end":11,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"only the last field of a struct may have a dynamically sized type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"change the field's type to have a statically known size","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"borrowed types always have a statically known size","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"the `Box` type always has a statically known size and allocates its contents in the heap","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"ledger/src/block.rs","byte_start":236,"byte_end":236,"line_start":11,"line_end":11,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":">","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: only the last field of a struct may have a dynamically sized type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: change the field's type to have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: borrowed types always have a statically known size\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92m&\u001b[0mHeader,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the `Box` type always has a statically known size and allocates its contents in the heap\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92mBox<\u001b[0mHeader\u001b[92m>\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++\u001b[0m      \u001b[92m+\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":236,"line_start":11,"line_end":11,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":23}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"only the last field of a struct may have a dynamically sized type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"change the field's type to have a statically known size","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"borrowed types always have a statically known size","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"the `Box` type always has a statically known size and allocates its contents in the heap","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"ledger/src/block.rs","byte_start":236,"byte_end":236,"line_start":11,"line_end":11,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":">","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: only the last field of a struct may have a dynamically sized type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: change the field's type to have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: borrowed types always have a statically known size\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92m&\u001b[0mHeader,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the `Box` type always has a statically known size and allocates its contents in the heap\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92mBox<\u001b[0mHeader\u001b[92m>\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++\u001b[0m      \u001b[92m+\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":236,"line_start":11,"line_end":11,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"only the last field of a struct may have a dynamically sized type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"change the field's type to have a statically known size","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"borrowed types always have a statically known size","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"the `Box` type always has a statically known size and allocates its contents in the heap","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"ledger/src/block.rs","byte_start":236,"byte_end":236,"line_start":11,"line_end":11,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":">","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: only the last field of a struct may have a dynamically sized type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: change the field's type to have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: borrowed types always have a statically known size\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92m&\u001b[0mHeader,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the `Box` type always has a statically known size and allocates its contents in the heap\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92mBox<\u001b[0mHeader\u001b[92m>\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++\u001b[0m      \u001b[92m+\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":236,"line_start":11,"line_end":11,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"only the last field of a struct may have a dynamically sized type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"change the field's type to have a statically known size","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"borrowed types always have a statically known size","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"the `Box` type always has a statically known size and allocates its contents in the heap","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":230,"byte_end":230,"line_start":11,"line_end":11,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"ledger/src/block.rs","byte_start":236,"byte_end":236,"line_start":11,"line_end":11,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":">","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: only the last field of a struct may have a dynamically sized type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: change the field's type to have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: borrowed types always have a statically known size\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92m&\u001b[0mHeader,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the `Box` type always has a statically known size and allocates its contents in the heap\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub header: \u001b[92mBox<\u001b[0mHeader\u001b[92m>\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++\u001b[0m      \u001b[92m+\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the return type of a function must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the return type of a function must have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the return type of a function must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the return type of a function must have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the return type of a function must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the return type of a function must have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the return type of a function must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the return type of a function must have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the return type of a function must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the return type of a function must have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the return type of a function must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the return type of a function must have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the return type of a function must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the return type of a function must have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the return type of a function must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the return type of a function must have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the return type of a function must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the return type of a function must have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the return type of a function must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the return type of a function must have a statically known size\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `T: minicbor::Encode<protocol::Era>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"the trait `minicbor::Encode<protocol::Era>` is not implemented for `T`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"required for `asset::Bundle<T>` to implement `minicbor::Encode<protocol::Era>`","code":null,"level":"note","spans":[{"file_name":"ledger/src/asset.rs","byte_start":592,"byte_end":603,"line_start":19,"line_end":19,"column_start":9,"column_end":20,"is_primary":false,"text":[{"text":"impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {","highlight_start":9,"highlight_end":20}],"label":"unsatisfied trait bound introduced here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":631,"byte_end":642,"line_start":19,"line_end":19,"column_start":48,"column_end":59,"is_primary":true,"text":[{"text":"impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {","highlight_start":48,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":647,"byte_end":656,"line_start":19,"line_end":19,"column_start":64,"column_end":73,"is_primary":true,"text":[{"text":"impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {","highlight_start":64,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `cbor_util::list_as_map::key_bytes::encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs","byte_start":1365,"byte_end":1378,"line_start":53,"line_end":53,"column_start":65,"column_end":78,"is_primary":true,"text":[{"text":"    pub fn encode<C, W: en::Write, T: bytes::EncodeBytes<C>, U: en::Encode<C>>(","highlight_start":65,"highlight_end":78}],"label":"required by this bound in `encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `T: minicbor::Encode<protocol::Era>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:5:62\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `minicbor::Encode<protocol::Era>` is not implemented for `T`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required for `asset::Bundle<T>` to implement `minicbor::Encode<protocol::Era>`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:19:48\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-----------\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94munsatisfied trait bound introduced here\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `cbor_util::list_as_map::key_bytes::encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs:53:65\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn encode<C, W: en::Write, T: bytes::EncodeBytes<C>, U: en::Encode<C>>(\n   \u001b[1m\u001b[94m|\u001b[0m                                                                 \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `for<'a> T: minicbor::Decode<'a, protocol::Era>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"the trait `for<'a> minicbor::Decode<'a, protocol::Era>` is not implemented for `T`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"required for `asset::Bundle<T>` to implement `minicbor::Encode<protocol::Era>`","code":null,"level":"note","spans":[{"file_name":"ledger/src/asset.rs","byte_start":606,"byte_end":629,"line_start":19,"line_end":19,"column_start":23,"column_end":46,"is_primary":false,"text":[{"text":"impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {","highlight_start":23,"highlight_end":46}],"label":"unsatisfied trait bound introduced here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":631,"byte_end":642,"line_start":19,"line_end":19,"column_start":48,"column_end":59,"is_primary":true,"text":[{"text":"impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {","highlight_start":48,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":647,"byte_end":656,"line_start":19,"line_end":19,"column_start":64,"column_end":73,"is_primary":true,"text":[{"text":"impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {","highlight_start":64,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `cbor_util::list_as_map::key_bytes::encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs","byte_start":1365,"byte_end":1378,"line_start":53,"line_end":53,"column_start":65,"column_end":78,"is_primary":true,"text":[{"text":"    pub fn encode<C, W: en::Write, T: bytes::EncodeBytes<C>, U: en::Encode<C>>(","highlight_start":65,"highlight_end":78}],"label":"required by this bound in `encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `for<'a> T: minicbor::Decode<'a, protocol::Era>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:5:62\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `for<'a> minicbor::Decode<'a, protocol::Era>` is not implemented for `T`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required for `asset::Bundle<T>` to implement `minicbor::Encode<protocol::Era>`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:19:48\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94m-----------------------\u001b[0m  \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94munsatisfied trait bound introduced here\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `cbor_util::list_as_map::key_bytes::encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs:53:65\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn encode<C, W: en::Write, T: bytes::EncodeBytes<C>, U: en::Encode<C>>(\n   \u001b[1m\u001b[94m|\u001b[0m                                                                 \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"expected `&mut Era`, found `&mut Ctx`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected mutable reference `&mut protocol::Era`\n   found mutable reference `&mut Ctx`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs","byte_start":1312,"byte_end":1318,"line_start":53,"line_end":53,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"    pub fn encode<C, W: en::Write, T: bytes::EncodeBytes<C>, U: en::Encode<C>>(","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:5:62\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91mexpected `&mut Era`, found `&mut Ctx`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected mutable reference `&mut \u001b[1m\u001b[35mprotocol::Era\u001b[0m`\n              found mutable reference `&mut \u001b[1m\u001b[35mCtx\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs:53:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn encode<C, W: en::Write, T: bytes::EncodeBytes<C>, U: en::Encode<C>>(\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`?` operator has incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/asset.rs","byte_start":166,"byte_end":172,"line_start":5,"line_end":5,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[([u8; 28], Bundle<T>)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/asset.rs","byte_start":166,"byte_end":172,"line_start":5,"line_end":5,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"`?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[([u8; 28], asset::Bundle<T>)]>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected struct `std::boxed::Box<[([u8; 28], asset::Bundle<T>)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `?` operator has incompatible types\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:5:70\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n  \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[([u8; 28], Bundle<T>)]>`, found `Vec<(_, _)>`\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[([u8; 28], asset::Bundle<T>)]>`\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[([u8; 28], asset::Bundle<T>)]>\u001b[0m`\n             found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `T: minicbor::Encode<protocol::Era>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"the trait `minicbor::Encode<protocol::Era>` is not implemented for `T`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"required for `asset::Bundle<T>` to implement `minicbor::Encode<protocol::Era>`","code":null,"level":"note","spans":[{"file_name":"ledger/src/asset.rs","byte_start":592,"byte_end":603,"line_start":19,"line_end":19,"column_start":9,"column_end":20,"is_primary":false,"text":[{"text":"impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {","highlight_start":9,"highlight_end":20}],"label":"unsatisfied trait bound introduced here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":631,"byte_end":642,"line_start":19,"line_end":19,"column_start":48,"column_end":59,"is_primary":true,"text":[{"text":"impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {","highlight_start":48,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":647,"byte_end":656,"line_start":19,"line_end":19,"column_start":64,"column_end":73,"is_primary":true,"text":[{"text":"impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {","highlight_start":64,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `cbor_util::list_as_map::key_bytes::encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs","byte_start":1365,"byte_end":1378,"line_start":53,"line_end":53,"column_start":65,"column_end":78,"is_primary":true,"text":[{"text":"    pub fn encode<C, W: en::Write, T: bytes::EncodeBytes<C>, U: en::Encode<C>>(","highlight_start":65,"highlight_end":78}],"label":"required by this bound in `encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `T: minicbor::Encode<protocol::Era>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:5:62\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `minicbor::Encode<protocol::Era>` is not implemented for `T`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required for `asset::Bundle<T>` to implement `minicbor::Encode<protocol::Era>`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:19:48\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-----------\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94munsatisfied trait bound introduced here\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `cbor_util::list_as_map::key_bytes::encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs:53:65\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn encode<C, W: en::Write, T: bytes::EncodeBytes<C>, U: en::Encode<C>>(\n   \u001b[1m\u001b[94m|\u001b[0m                                                                 \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `T: minicbor::CborLen<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/asset.rs","byte_start":467,"byte_end":474,"line_start":15,"line_end":15,"column_start":62,"column_end":69,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, CborLen)]","highlight_start":62,"highlight_end":69}],"label":"the trait `minicbor::CborLen<_>` is not implemented for `T`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/asset.rs","byte_start":467,"byte_end":474,"line_start":15,"line_end":15,"column_start":62,"column_end":69,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, CborLen)]","highlight_start":62,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `minicbor::CborLen<C>`:\n  &T\n  &mut T","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `cbor_util::list_as_map::cbor_len`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs","byte_start":889,"byte_end":901,"line_start":34,"line_end":34,"column_start":42,"column_end":54,"is_primary":true,"text":[{"text":"pub fn cbor_len<Ctx, K: CborLen<Ctx>, V: CborLen<Ctx>>(","highlight_start":42,"highlight_end":54}],"label":"required by this bound in `cbor_len`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `T: minicbor::CborLen<_>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:15:62\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `minicbor::CborLen<_>` is not implemented for `T`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `minicbor::CborLen<C>`:\n             &T\n             &mut T\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `cbor_util::list_as_map::cbor_len`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs:34:42\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn cbor_len<Ctx, K: CborLen<Ctx>, V: CborLen<Ctx>>(\n   \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[92m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `cbor_len`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `for<'a> T: minicbor::Decode<'a, protocol::Era>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"the trait `for<'a> minicbor::Decode<'a, protocol::Era>` is not implemented for `T`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"required for `asset::Bundle<T>` to implement `minicbor::Encode<protocol::Era>`","code":null,"level":"note","spans":[{"file_name":"ledger/src/asset.rs","byte_start":606,"byte_end":629,"line_start":19,"line_end":19,"column_start":23,"column_end":46,"is_primary":false,"text":[{"text":"impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {","highlight_start":23,"highlight_end":46}],"label":"unsatisfied trait bound introduced here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":631,"byte_end":642,"line_start":19,"line_end":19,"column_start":48,"column_end":59,"is_primary":true,"text":[{"text":"impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {","highlight_start":48,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":647,"byte_end":656,"line_start":19,"line_end":19,"column_start":64,"column_end":73,"is_primary":true,"text":[{"text":"impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {","highlight_start":64,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `cbor_util::list_as_map::key_bytes::encode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs","byte_start":1365,"byte_end":1378,"line_start":53,"line_end":53,"column_start":65,"column_end":78,"is_primary":true,"text":[{"text":"    pub fn encode<C, W: en::Write, T: bytes::EncodeBytes<C>, U: en::Encode<C>>(","highlight_start":65,"highlight_end":78}],"label":"required by this bound in `encode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `for<'a> T: minicbor::Decode<'a, protocol::Era>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:5:62\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `for<'a> minicbor::Decode<'a, protocol::Era>` is not implemented for `T`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required for `asset::Bundle<T>` to implement `minicbor::Encode<protocol::Era>`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:19:48\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m impl<T: Encode<Era> + for<'a> Decode<'a, Era>> Encode<Era> for Bundle<T> {\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94m-----------------------\u001b[0m  \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94munsatisfied trait bound introduced here\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `cbor_util::list_as_map::key_bytes::encode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs:53:65\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn encode<C, W: en::Write, T: bytes::EncodeBytes<C>, U: en::Encode<C>>(\n   \u001b[1m\u001b[94m|\u001b[0m                                                                 \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `encode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type mismatch in function arguments","code":{"code":"E0631","explanation":"This error indicates a type mismatch in closure arguments.\n\nErroneous code example:\n\n```compile_fail,E0631\nfn foo<F: Fn(i32)>(f: F) {\n}\n\nfn main() {\n    foo(|x: &str| {});\n}\n```\n\nThe error occurs because `foo` accepts a closure that takes an `i32` argument,\nbut in `main`, it is passed a closure with a `&str` argument.\n\nThis can be resolved by changing the type annotation or removing it entirely\nif it can be inferred.\n\n```\nfn foo<F: Fn(i32)>(f: F) {\n}\n\nfn main() {\n    foo(|x: i32| {});\n}\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/asset.rs","byte_start":1526,"byte_end":1532,"line_start":45,"line_end":45,"column_start":52,"column_end":58,"is_primary":true,"text":[{"text":"        cbor_util::list_as_map::decode(d, era).map(Bundle)","highlight_start":52,"highlight_end":58}],"label":"expected due to this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":498,"byte_end":518,"line_start":17,"line_end":17,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct Bundle<T>(#[cbor(with = \"cbor_util::list_as_map\")] pub Box<[(Name, T)]>);","highlight_start":1,"highlight_end":21}],"label":"found signature defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":1522,"byte_end":1525,"line_start":45,"line_end":45,"column_start":48,"column_end":51,"is_primary":false,"text":[{"text":"        cbor_util::list_as_map::decode(d, era).map(Bundle)","highlight_start":48,"highlight_end":51}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected function signature `fn(std::vec::Vec<(_, _)>) -> _`\n   found function signature `fn(std::boxed::Box<[(asset::Name, _)]>) -> _`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `std::result::Result::<T, E>::map`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":30043,"byte_end":30046,"line_start":831,"line_end":831,"column_start":18,"column_end":21,"is_primary":false,"text":[{"text":"    pub const fn map<U, F>(self, op: F) -> Result<U, E>","highlight_start":18,"highlight_end":21}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":30103,"byte_end":30125,"line_start":833,"line_end":833,"column_start":12,"column_end":34,"is_primary":true,"text":[{"text":"        F: [const] FnOnce(T) -> U + [const] Destruct,","highlight_start":12,"highlight_end":34}],"label":"required by this bound in `Result::<T, E>::map`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider wrapping the function in a closure","code":null,"level":"help","spans":[{"file_name":"ledger/src/asset.rs","byte_start":1526,"byte_end":1526,"line_start":45,"line_end":45,"column_start":52,"column_end":52,"is_primary":true,"text":[{"text":"        cbor_util::list_as_map::decode(d, era).map(Bundle)","highlight_start":52,"highlight_end":52}],"label":null,"suggested_replacement":"|arg0| ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":1532,"byte_end":1532,"line_start":45,"line_end":45,"column_start":58,"column_end":58,"is_primary":true,"text":[{"text":"        cbor_util::list_as_map::decode(d, era).map(Bundle)","highlight_start":58,"highlight_end":58}],"label":null,"suggested_replacement":"(/* std::boxed::Box<[(asset::Name, _)]> */)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0631]\u001b[0m\u001b[1m: type mismatch in function arguments\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:45:52\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bundle<T>(#[cbor(with = \"cbor_util::list_as_map\")] pub Box<[(Name, T)]>);\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m--------------------\u001b[0m \u001b[1m\u001b[94mfound signature defined here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         cbor_util::list_as_map::decode(d, era).map(Bundle)\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected due to this\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected function signature `fn(std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m) -> \u001b[1m\u001b[35m_\u001b[0m`\n               found function signature `fn(std::\u001b[1m\u001b[35mboxed::Box<[(asset::Name, _)]>\u001b[0m) -> \u001b[1m\u001b[35m_\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::result::Result::<T, E>::map`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:833:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m831\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub const fn map<U, F>(self, op: F) -> Result<U, E>\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[94m832\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n\u001b[1m\u001b[94m833\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         F: [const] FnOnce(T) -> U + [const] Destruct,\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Result::<T, E>::map`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider wrapping the function in a closure\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        cbor_util::list_as_map::decode(d, era).map(\u001b[92m|arg0| \u001b[0mBundle\u001b[92m(/* std::boxed::Box<[(asset::Name, _)]> */)\u001b[0m)\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[92m++++++\u001b[0m       \u001b[92m+++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"expected `&mut Era`, found `&mut Ctx`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/asset.rs","byte_start":158,"byte_end":164,"line_start":5,"line_end":5,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected mutable reference `&mut protocol::Era`\n   found mutable reference `&mut Ctx`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs","byte_start":1312,"byte_end":1318,"line_start":53,"line_end":53,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"    pub fn encode<C, W: en::Write, T: bytes::EncodeBytes<C>, U: en::Encode<C>>(","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:5:62\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91mexpected `&mut Era`, found `&mut Ctx`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected mutable reference `&mut \u001b[1m\u001b[35mprotocol::Era\u001b[0m`\n              found mutable reference `&mut \u001b[1m\u001b[35mCtx\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs:53:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn encode<C, W: en::Write, T: bytes::EncodeBytes<C>, U: en::Encode<C>>(\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":246,"byte_end":251,"line_start":15,"line_end":15,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`?` operator has incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/asset.rs","byte_start":166,"byte_end":172,"line_start":5,"line_end":5,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[([u8; 28], Bundle<T>)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/asset.rs","byte_start":166,"byte_end":172,"line_start":5,"line_end":5,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"`?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[([u8; 28], asset::Bundle<T>)]>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected struct `std::boxed::Box<[([u8; 28], asset::Bundle<T>)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `?` operator has incompatible types\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:5:70\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n  \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[([u8; 28], Bundle<T>)]>`, found `Vec<(_, _)>`\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[([u8; 28], asset::Bundle<T>)]>`\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[([u8; 28], asset::Bundle<T>)]>\u001b[0m`\n             found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `T: minicbor::CborLen<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/asset.rs","byte_start":467,"byte_end":474,"line_start":15,"line_end":15,"column_start":62,"column_end":69,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, CborLen)]","highlight_start":62,"highlight_end":69}],"label":"the trait `minicbor::CborLen<_>` is not implemented for `T`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/asset.rs","byte_start":467,"byte_end":474,"line_start":15,"line_end":15,"column_start":62,"column_end":69,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, CborLen)]","highlight_start":62,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `minicbor::CborLen<C>`:\n  &T\n  &mut T","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `cbor_util::list_as_map::cbor_len`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs","byte_start":889,"byte_end":901,"line_start":34,"line_end":34,"column_start":42,"column_end":54,"is_primary":true,"text":[{"text":"pub fn cbor_len<Ctx, K: CborLen<Ctx>, V: CborLen<Ctx>>(","highlight_start":42,"highlight_end":54}],"label":"required by this bound in `cbor_len`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `T: minicbor::CborLen<_>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:15:62\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `minicbor::CborLen<_>` is not implemented for `T`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `minicbor::CborLen<C>`:\n             &T\n             &mut T\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `cbor_util::list_as_map::cbor_len`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/list_as_map.rs:34:42\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn cbor_len<Ctx, K: CborLen<Ctx>, V: CborLen<Ctx>>(\n   \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[92m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `cbor_len`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type mismatch in function arguments","code":{"code":"E0631","explanation":"This error indicates a type mismatch in closure arguments.\n\nErroneous code example:\n\n```compile_fail,E0631\nfn foo<F: Fn(i32)>(f: F) {\n}\n\nfn main() {\n    foo(|x: &str| {});\n}\n```\n\nThe error occurs because `foo` accepts a closure that takes an `i32` argument,\nbut in `main`, it is passed a closure with a `&str` argument.\n\nThis can be resolved by changing the type annotation or removing it entirely\nif it can be inferred.\n\n```\nfn foo<F: Fn(i32)>(f: F) {\n}\n\nfn main() {\n    foo(|x: i32| {});\n}\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/asset.rs","byte_start":1526,"byte_end":1532,"line_start":45,"line_end":45,"column_start":52,"column_end":58,"is_primary":true,"text":[{"text":"        cbor_util::list_as_map::decode(d, era).map(Bundle)","highlight_start":52,"highlight_end":58}],"label":"expected due to this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":498,"byte_end":518,"line_start":17,"line_end":17,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct Bundle<T>(#[cbor(with = \"cbor_util::list_as_map\")] pub Box<[(Name, T)]>);","highlight_start":1,"highlight_end":21}],"label":"found signature defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":1522,"byte_end":1525,"line_start":45,"line_end":45,"column_start":48,"column_end":51,"is_primary":false,"text":[{"text":"        cbor_util::list_as_map::decode(d, era).map(Bundle)","highlight_start":48,"highlight_end":51}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected function signature `fn(std::vec::Vec<(_, _)>) -> _`\n   found function signature `fn(std::boxed::Box<[(asset::Name, _)]>) -> _`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `std::result::Result::<T, E>::map`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":30043,"byte_end":30046,"line_start":831,"line_end":831,"column_start":18,"column_end":21,"is_primary":false,"text":[{"text":"    pub const fn map<U, F>(self, op: F) -> Result<U, E>","highlight_start":18,"highlight_end":21}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":30103,"byte_end":30125,"line_start":833,"line_end":833,"column_start":12,"column_end":34,"is_primary":true,"text":[{"text":"        F: [const] FnOnce(T) -> U + [const] Destruct,","highlight_start":12,"highlight_end":34}],"label":"required by this bound in `Result::<T, E>::map`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider wrapping the function in a closure","code":null,"level":"help","spans":[{"file_name":"ledger/src/asset.rs","byte_start":1526,"byte_end":1526,"line_start":45,"line_end":45,"column_start":52,"column_end":52,"is_primary":true,"text":[{"text":"        cbor_util::list_as_map::decode(d, era).map(Bundle)","highlight_start":52,"highlight_end":52}],"label":null,"suggested_replacement":"|arg0| ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"ledger/src/asset.rs","byte_start":1532,"byte_end":1532,"line_start":45,"line_end":45,"column_start":58,"column_end":58,"is_primary":true,"text":[{"text":"        cbor_util::list_as_map::decode(d, era).map(Bundle)","highlight_start":58,"highlight_end":58}],"label":null,"suggested_replacement":"(/* std::boxed::Box<[(asset::Name, _)]> */)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0631]\u001b[0m\u001b[1m: type mismatch in function arguments\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/asset.rs:45:52\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bundle<T>(#[cbor(with = \"cbor_util::list_as_map\")] pub Box<[(Name, T)]>);\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m--------------------\u001b[0m \u001b[1m\u001b[94mfound signature defined here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         cbor_util::list_as_map::decode(d, era).map(Bundle)\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected due to this\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected function signature `fn(std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m) -> \u001b[1m\u001b[35m_\u001b[0m`\n               found function signature `fn(std::\u001b[1m\u001b[35mboxed::Box<[(asset::Name, _)]>\u001b[0m) -> \u001b[1m\u001b[35m_\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::result::Result::<T, E>::map`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:833:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m831\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub const fn map<U, F>(self, op: F) -> Result<U, E>\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[94m832\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n\u001b[1m\u001b[94m833\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         F: [const] FnOnce(T) -> U + [const] Destruct,\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Result::<T, E>::map`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider wrapping the function in a closure\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        cbor_util::list_as_map::decode(d, era).map(\u001b[92m|arg0| \u001b[0mBundle\u001b[92m(/* std::boxed::Box<[(asset::Name, _)]> */)\u001b[0m)\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[92m++++++\u001b[0m       \u001b[92m+++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":246,"byte_end":251,"line_start":15,"line_end":15,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":5917,"byte_end":5926,"line_start":189,"line_end":189,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Signature<S, L, R>","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:189:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Signature<S, L, R>\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":246,"byte_end":251,"line_start":15,"line_end":15,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":246,"byte_end":251,"line_start":15,"line_end":15,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":5917,"byte_end":5926,"line_start":189,"line_end":189,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Signature<S, L, R>","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:189:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Signature<S, L, R>\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":246,"byte_end":251,"line_start":15,"line_end":15,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":5917,"byte_end":5926,"line_start":189,"line_end":189,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Signature<S, L, R>","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:189:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Signature<S, L, R>\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":246,"byte_end":251,"line_start":15,"line_end":15,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":5917,"byte_end":5926,"line_start":189,"line_end":189,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Signature<S, L, R>","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:189:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Signature<S, L, R>\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":246,"byte_end":251,"line_start":15,"line_end":15,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":5917,"byte_end":5926,"line_start":189,"line_end":189,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Signature<S, L, R>","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:189:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Signature<S, L, R>\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":246,"byte_end":251,"line_start":15,"line_end":15,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":5917,"byte_end":5926,"line_start":189,"line_end":189,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Signature<S, L, R>","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:189:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Signature<S, L, R>\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":246,"byte_end":251,"line_start":15,"line_end":15,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":5917,"byte_end":5926,"line_start":189,"line_end":189,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Signature<S, L, R>","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:189:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Signature<S, L, R>\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":246,"byte_end":251,"line_start":15,"line_end":15,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":5917,"byte_end":5926,"line_start":189,"line_end":189,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Signature<S, L, R>","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:189:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Signature<S, L, R>\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&&Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to `&dyn std::fmt::Debug`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"binary operation `==` cannot be applied to type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`","code":{"code":"E0369","explanation":"A binary operation was attempted on a type which doesn't support it.\n\nErroneous code example:\n\n```compile_fail,E0369\nlet x = 12f32; // error: binary operation `<<` cannot be applied to\n               //        type `f32`\n\nx << 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet x = 12u32; // the `u32` type does implement it:\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n\nx << 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing traits from `std::ops`.\n\nString concatenation appends the string on the right to the string on the\nleft and may require reallocation. This requires ownership of the string\non the left. If something should be added to a string literal, move the\nliteral to the heap by allocating it with `to_owned()` like in\n`\"Your text\".to_owned()`.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the foreign item types don't implement required traits for this operation to be valid","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/single_use.rs","byte_start":713,"byte_end":736,"line_start":18,"line_end":18,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub struct SingleUse<T>(pub T);","highlight_start":1,"highlight_end":24}],"label":"not implement `digest::crypto_common::KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1174,"byte_end":1197,"line_start":35,"line_end":35,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":1,"highlight_end":24}],"label":"not implement `digest::crypto_common::KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1174,"byte_end":1197,"line_start":35,"line_end":35,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":1,"highlight_end":24}],"label":"not implement `digest::crypto_common::KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1174,"byte_end":1197,"line_start":35,"line_end":35,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":1,"highlight_end":24}],"label":"not implement `digest::crypto_common::KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1174,"byte_end":1197,"line_start":35,"line_end":35,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":1,"highlight_end":24}],"label":"not implement `digest::crypto_common::KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-8013594591332930084.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0369]\u001b[0m\u001b[1m: binary operation `==` cannot be applied to type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: the foreign item types don't implement required traits for this operation to be valid\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:35:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92mnot implement `digest::crypto_common::KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92mnot implement `digest::crypto_common::KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92mnot implement `digest::crypto_common::KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92mnot implement `digest::crypto_common::KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/charles/Code/pallas-extras/kes/src/single_use.rs:18:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct SingleUse<T>(pub T);\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mnot implement `digest::crypto_common::KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-8013594591332930084.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":271,"byte_end":273,"line_start":15,"line_end":15,"column_start":35,"column_end":37,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":35,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Eq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":13141,"byte_end":13153,"line_start":356,"line_end":356,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"pub macro Eq($item:item) {","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":271,"byte_end":273,"line_start":15,"line_end":15,"column_start":35,"column_end":37,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":35,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Eq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":13141,"byte_end":13153,"line_start":356,"line_end":356,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"pub macro Eq($item:item) {","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":271,"byte_end":273,"line_start":15,"line_end":15,"column_start":35,"column_end":37,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":35,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Eq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":13141,"byte_end":13153,"line_start":356,"line_end":356,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"pub macro Eq($item:item) {","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":253,"byte_end":258,"line_start":15,"line_end":15,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":271,"byte_end":273,"line_start":15,"line_end":15,"column_start":35,"column_end":37,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":35,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Eq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":13141,"byte_end":13153,"line_start":356,"line_end":356,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"pub macro Eq($item:item) {","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":271,"byte_end":273,"line_start":15,"line_end":15,"column_start":35,"column_end":37,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":35,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Eq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":13141,"byte_end":13153,"line_start":356,"line_end":356,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"pub macro Eq($item:item) {","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"binary operation `==` cannot be applied to type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`","code":{"code":"E0369","explanation":"A binary operation was attempted on a type which doesn't support it.\n\nErroneous code example:\n\n```compile_fail,E0369\nlet x = 12f32; // error: binary operation `<<` cannot be applied to\n               //        type `f32`\n\nx << 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet x = 12u32; // the `u32` type does implement it:\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n\nx << 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing traits from `std::ops`.\n\nString concatenation appends the string on the right to the string on the\nleft and may require reallocation. This requires ownership of the string\non the left. If something should be added to a string literal, move the\nliteral to the heap by allocating it with `to_owned()` like in\n`\"Your text\".to_owned()`.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":260,"byte_end":269,"line_start":15,"line_end":15,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the foreign item types don't implement required traits for this operation to be valid","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/single_use.rs","byte_start":713,"byte_end":736,"line_start":18,"line_end":18,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub struct SingleUse<T>(pub T);","highlight_start":1,"highlight_end":24}],"label":"not implement `digest::crypto_common::KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1174,"byte_end":1197,"line_start":35,"line_end":35,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":1,"highlight_end":24}],"label":"not implement `digest::crypto_common::KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1174,"byte_end":1197,"line_start":35,"line_end":35,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":1,"highlight_end":24}],"label":"not implement `digest::crypto_common::KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1174,"byte_end":1197,"line_start":35,"line_end":35,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":1,"highlight_end":24}],"label":"not implement `digest::crypto_common::KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1174,"byte_end":1197,"line_start":35,"line_end":35,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":1,"highlight_end":24}],"label":"not implement `digest::crypto_common::KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-15151973545163388437.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0369]\u001b[0m\u001b[1m: binary operation `==` cannot be applied to type `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: the foreign item types don't implement required traits for this operation to be valid\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:35:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92mnot implement `digest::crypto_common::KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92mnot implement `digest::crypto_common::KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92mnot implement `digest::crypto_common::KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92mnot implement `digest::crypto_common::KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/charles/Code/pallas-extras/kes/src/single_use.rs:18:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct SingleUse<T>(pub T);\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mnot implement `digest::crypto_common::KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-15151973545163388437.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":271,"byte_end":273,"line_start":15,"line_end":15,"column_start":35,"column_end":37,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":35,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Eq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":13141,"byte_end":13153,"line_start":356,"line_end":356,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"pub macro Eq($item:item) {","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":271,"byte_end":273,"line_start":15,"line_end":15,"column_start":35,"column_end":37,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":35,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Eq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":13141,"byte_end":13153,"line_start":356,"line_end":356,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"pub macro Eq($item:item) {","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":271,"byte_end":273,"line_start":15,"line_end":15,"column_start":35,"column_end":37,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":35,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Eq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":13141,"byte_end":13153,"line_start":356,"line_end":356,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"pub macro Eq($item:item) {","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":271,"byte_end":273,"line_start":15,"line_end":15,"column_start":35,"column_end":37,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":35,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Eq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":13141,"byte_end":13153,"line_start":356,"line_end":356,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"pub macro Eq($item:item) {","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":412,"byte_end":449,"line_start":21,"line_end":21,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub signature: crypto::kes::Signature,","highlight_start":5,"highlight_end":42}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":271,"byte_end":273,"line_start":15,"line_end":15,"column_start":35,"column_end":37,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":35,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Eq)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":13141,"byte_end":13153,"line_start":356,"line_end":356,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"pub macro Eq($item:item) {","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub signature: crypto::kes::Signature,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `VerifyingKey<VerifyingKey>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::single_use::VerifyingKey<ed25519_dalek::VerifyingKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::single_use::VerifyingKey<VK>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature, SingleUse<SigningKey>, SingleUse<SigningKey>>` to implement `ecdsa::SignatureEncoding`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"5 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::SignatureEncoding`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11270704046469052674.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `VerifyingKey<VerifyingKey>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::single_use::VerifyingKey<ed25519_dalek::VerifyingKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::single_use::VerifyingKey<VK>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature, SingleUse<SigningKey>, SingleUse<SigningKey>>` to implement `ecdsa::SignatureEncoding`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 5 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::SignatureEncoding`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11270704046469052674.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `VerifyingKey<VerifyingKey>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::single_use::VerifyingKey<ed25519_dalek::VerifyingKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":275,"byte_end":281,"line_start":15,"line_end":15,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::single_use::VerifyingKey<VK>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature, SingleUse<SigningKey>, SingleUse<SigningKey>>` to implement `ecdsa::SignatureEncoding`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"5 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::SignatureEncoding`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-8006755938033771131.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `VerifyingKey<VerifyingKey>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::single_use::VerifyingKey<ed25519_dalek::VerifyingKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::single_use::VerifyingKey<VK>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature, SingleUse<SigningKey>, SingleUse<SigningKey>>` to implement `ecdsa::SignatureEncoding`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 5 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::SignatureEncoding`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-8006755938033771131.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Signature<Signature<..., ..., ...>, ..., ...>: TryFrom<...>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `for<'a> std::convert::TryFrom<&'a [u8]>` is not implemented for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `std::convert::TryFrom<&[u8]>` is implemented for `kes::sum::Signature<S, L, R>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `cbor_util::signature::decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs","byte_start":511,"byte_end":517,"line_start":17,"line_end":17,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"pub fn decode<S, Ctx>(d: &mut Decoder<'_>, _: &mut Ctx) -> Result<S, de::Error>","highlight_start":8,"highlight_end":14}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs","byte_start":625,"byte_end":701,"line_start":20,"line_end":20,"column_start":11,"column_end":87,"is_primary":true,"text":[{"text":"        + for<'a> TryFrom<&'a [u8], Error: core::error::Error + Send + Sync + 'static>,","highlight_start":11,"highlight_end":87}],"label":"required by this bound in `decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-8013594591332930084.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Signature<Signature<..., ..., ...>, ..., ...>: TryFrom<...>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `for<'a> std::convert::TryFrom<&'a [u8]>` is not implemented for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `std::convert::TryFrom<&[u8]>` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::sum::Signature<S, L, R>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `cbor_util::signature::decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs:20:11\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn decode<S, Ctx>(d: &mut Decoder<'_>, _: &mut Ctx) -> Result<S, de::Error>\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         + for<'a> TryFrom<&'a [u8], Error: core::error::Error + Send + Sync + 'static>,\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-8013594591332930084.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `VerifyingKey<VerifyingKey>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::single_use::VerifyingKey<ed25519_dalek::VerifyingKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::single_use::VerifyingKey<VK>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature, SingleUse<SigningKey>, SingleUse<SigningKey>>` to implement `ecdsa::SignatureEncoding`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"5 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::SignatureEncoding`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `cbor_util::signature::decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs","byte_start":511,"byte_end":517,"line_start":17,"line_end":17,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"pub fn decode<S, Ctx>(d: &mut Decoder<'_>, _: &mut Ctx) -> Result<S, de::Error>","highlight_start":8,"highlight_end":14}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs","byte_start":597,"byte_end":614,"line_start":19,"line_end":19,"column_start":8,"column_end":25,"is_primary":true,"text":[{"text":"    S: SignatureEncoding","highlight_start":8,"highlight_end":25}],"label":"required by this bound in `decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11270704046469052674.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `VerifyingKey<VerifyingKey>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::single_use::VerifyingKey<ed25519_dalek::VerifyingKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::single_use::VerifyingKey<VK>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature, SingleUse<SigningKey>, SingleUse<SigningKey>>` to implement `ecdsa::SignatureEncoding`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 5 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::SignatureEncoding`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `cbor_util::signature::decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs:19:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn decode<S, Ctx>(d: &mut Decoder<'_>, _: &mut Ctx) -> Result<S, de::Error>\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     S: SignatureEncoding\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11270704046469052674.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Signature<Signature<..., ..., ...>, ..., ...>: TryFrom<...>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `for<'a> std::convert::TryFrom<&'a [u8]>` is not implemented for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `std::convert::TryFrom<&[u8]>` is implemented for `kes::sum::Signature<S, L, R>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `cbor_util::signature::decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs","byte_start":511,"byte_end":517,"line_start":17,"line_end":17,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"pub fn decode<S, Ctx>(d: &mut Decoder<'_>, _: &mut Ctx) -> Result<S, de::Error>","highlight_start":8,"highlight_end":14}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs","byte_start":625,"byte_end":701,"line_start":20,"line_end":20,"column_start":11,"column_end":87,"is_primary":true,"text":[{"text":"        + for<'a> TryFrom<&'a [u8], Error: core::error::Error + Send + Sync + 'static>,","highlight_start":11,"highlight_end":87}],"label":"required by this bound in `decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-15151973545163388437.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Signature<Signature<..., ..., ...>, ..., ...>: TryFrom<...>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `for<'a> std::convert::TryFrom<&'a [u8]>` is not implemented for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `std::convert::TryFrom<&[u8]>` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::sum::Signature<S, L, R>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `cbor_util::signature::decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs:20:11\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn decode<S, Ctx>(d: &mut Decoder<'_>, _: &mut Ctx) -> Result<S, de::Error>\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         + for<'a> TryFrom<&'a [u8], Error: core::error::Error + Send + Sync + 'static>,\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-15151973545163388437.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `VerifyingKey<VerifyingKey>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::single_use::VerifyingKey<ed25519_dalek::VerifyingKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":283,"byte_end":289,"line_start":15,"line_end":15,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::single_use::VerifyingKey<VK>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature, SingleUse<SigningKey>, SingleUse<SigningKey>>` to implement `ecdsa::SignatureEncoding`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"5 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::SignatureEncoding`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `cbor_util::signature::decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs","byte_start":511,"byte_end":517,"line_start":17,"line_end":17,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"pub fn decode<S, Ctx>(d: &mut Decoder<'_>, _: &mut Ctx) -> Result<S, de::Error>","highlight_start":8,"highlight_end":14}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs","byte_start":597,"byte_end":614,"line_start":19,"line_end":19,"column_start":8,"column_end":25,"is_primary":true,"text":[{"text":"    S: SignatureEncoding","highlight_start":8,"highlight_end":25}],"label":"required by this bound in `decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-8006755938033771131.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `VerifyingKey<VerifyingKey>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::single_use::VerifyingKey<ed25519_dalek::VerifyingKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::single_use::VerifyingKey<VK>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature, SingleUse<SigningKey>, SingleUse<SigningKey>>` to implement `ecdsa::SignatureEncoding`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 5 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::SignatureEncoding`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `cbor_util::signature::decode`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs:19:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn decode<S, Ctx>(d: &mut Decoder<'_>, _: &mut Ctx) -> Result<S, de::Error>\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     S: SignatureEncoding\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `decode`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-8006755938033771131.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `VerifyingKey<VerifyingKey>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::single_use::VerifyingKey<ed25519_dalek::VerifyingKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::single_use::VerifyingKey<VK>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature, SingleUse<SigningKey>, SingleUse<SigningKey>>` to implement `ecdsa::SignatureEncoding`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"5 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::SignatureEncoding`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `cbor_util::signature::cbor_len`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs","byte_start":793,"byte_end":801,"line_start":26,"line_end":26,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn cbor_len<S, Ctx>(value: &S, ctx: &mut Ctx) -> usize","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs","byte_start":858,"byte_end":875,"line_start":28,"line_end":28,"column_start":8,"column_end":25,"is_primary":true,"text":[{"text":"    S: SignatureEncoding,","highlight_start":8,"highlight_end":25}],"label":"required by this bound in `cbor_len`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11270704046469052674.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `VerifyingKey<VerifyingKey>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::single_use::VerifyingKey<ed25519_dalek::VerifyingKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::single_use::VerifyingKey<VK>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature, SingleUse<SigningKey>, SingleUse<SigningKey>>` to implement `ecdsa::SignatureEncoding`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 5 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::SignatureEncoding`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `cbor_util::signature::cbor_len`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs:28:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn cbor_len<S, Ctx>(value: &S, ctx: &mut Ctx) -> usize\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     S: SignatureEncoding,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `cbor_len`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11270704046469052674.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `kes::Sum`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1185,"byte_end":1188,"line_start":35,"line_end":35,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1230,"byte_end":1241,"line_start":38,"line_end":38,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    R: KeySizeUser + KeypairRef,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `Sum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `kes::Sum`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     R: KeySizeUser + KeypairRef,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sum`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `VerifyingKey<VerifyingKey>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::single_use::VerifyingKey<ed25519_dalek::VerifyingKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block/header.rs","byte_start":291,"byte_end":298,"line_start":15,"line_end":15,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::single_use::VerifyingKey<VK>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature, SingleUse<SigningKey>, SingleUse<SigningKey>>` to implement `ecdsa::SignatureEncoding`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"5 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::SignatureEncoding`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `cbor_util::signature::cbor_len`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs","byte_start":793,"byte_end":801,"line_start":26,"line_end":26,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn cbor_len<S, Ctx>(value: &S, ctx: &mut Ctx) -> usize","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs","byte_start":858,"byte_end":875,"line_start":28,"line_end":28,"column_start":8,"column_end":25,"is_primary":true,"text":[{"text":"    S: SignatureEncoding,","highlight_start":8,"highlight_end":25}],"label":"required by this bound in `cbor_len`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-8006755938033771131.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `VerifyingKey<VerifyingKey>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:15:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::single_use::VerifyingKey<ed25519_dalek::VerifyingKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::single_use::VerifyingKey<VK>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature, SingleUse<SigningKey>, SingleUse<SigningKey>>` to implement `ecdsa::SignatureEncoding`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 5 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Signature<Signature<Signature<..., ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::SignatureEncoding`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `cbor_util::signature::cbor_len`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/Code/pallas-extras/cbor-util/src/signature.rs:28:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn cbor_len<S, Ctx>(value: &S, ctx: &mut Ctx) -> usize\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     S: SignatureEncoding,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `cbor_len`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-8006755938033771131.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":128,"byte_end":133,"line_start":8,"line_end":8,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":128,"byte_end":133,"line_start":8,"line_end":8,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":128,"byte_end":133,"line_start":8,"line_end":8,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":128,"byte_end":133,"line_start":8,"line_end":8,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":128,"byte_end":133,"line_start":8,"line_end":8,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":128,"byte_end":133,"line_start":8,"line_end":8,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":135,"byte_end":140,"line_start":8,"line_end":8,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone::clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":8836,"byte_end":8841,"line_start":236,"line_end":236,"column_start":8,"column_end":13,"is_primary":false,"text":[{"text":"    fn clone(&self) -> Self;","highlight_start":8,"highlight_end":13}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone::clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone::clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone::clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn clone(&self) -> Self;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":128,"byte_end":133,"line_start":8,"line_end":8,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":135,"byte_end":140,"line_start":8,"line_end":8,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone::clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":8836,"byte_end":8841,"line_start":236,"line_end":236,"column_start":8,"column_end":13,"is_primary":false,"text":[{"text":"    fn clone(&self) -> Self;","highlight_start":8,"highlight_end":13}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone::clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone::clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone::clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn clone(&self) -> Self;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":128,"byte_end":133,"line_start":8,"line_end":8,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":135,"byte_end":140,"line_start":8,"line_end":8,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone::clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":8836,"byte_end":8841,"line_start":236,"line_end":236,"column_start":8,"column_end":13,"is_primary":false,"text":[{"text":"    fn clone(&self) -> Self;","highlight_start":8,"highlight_end":13}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone::clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone::clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone::clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn clone(&self) -> Self;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":128,"byte_end":133,"line_start":8,"line_end":8,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":135,"byte_end":140,"line_start":8,"line_end":8,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone::clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":8836,"byte_end":8841,"line_start":236,"line_end":236,"column_start":8,"column_end":13,"is_primary":false,"text":[{"text":"    fn clone(&self) -> Self;","highlight_start":8,"highlight_end":13}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone::clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone::clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone::clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn clone(&self) -> Self;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":128,"byte_end":133,"line_start":8,"line_end":8,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `&block::header::Header` to `&dyn std::fmt::Debug`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":135,"byte_end":140,"line_start":8,"line_end":8,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone::clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":8836,"byte_end":8841,"line_start":236,"line_end":236,"column_start":8,"column_end":13,"is_primary":false,"text":[{"text":"    fn clone(&self) -> Self;","highlight_start":8,"highlight_end":13}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone::clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone::clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone::clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn clone(&self) -> Self;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":135,"byte_end":140,"line_start":8,"line_end":8,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone::clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":8836,"byte_end":8841,"line_start":236,"line_end":236,"column_start":8,"column_end":13,"is_primary":false,"text":[{"text":"    fn clone(&self) -> Self;","highlight_start":8,"highlight_end":13}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone::clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone::clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone::clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn clone(&self) -> Self;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:39\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":135,"byte_end":140,"line_start":8,"line_end":8,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone::clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":8836,"byte_end":8841,"line_start":236,"line_end":236,"column_start":8,"column_end":13,"is_primary":false,"text":[{"text":"    fn clone(&self) -> Self;","highlight_start":8,"highlight_end":13}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone::clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone::clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone::clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn clone(&self) -> Self;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:39\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":135,"byte_end":140,"line_start":8,"line_end":8,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone::clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":8836,"byte_end":8841,"line_start":236,"line_end":236,"column_start":8,"column_end":13,"is_primary":false,"text":[{"text":"    fn clone(&self) -> Self;","highlight_start":8,"highlight_end":13}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone::clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone::clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone::clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn clone(&self) -> Self;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:39\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":135,"byte_end":140,"line_start":8,"line_end":8,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone::clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":8836,"byte_end":8841,"line_start":236,"line_end":236,"column_start":8,"column_end":13,"is_primary":false,"text":[{"text":"    fn clone(&self) -> Self;","highlight_start":8,"highlight_end":13}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone::clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone::clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone::clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn clone(&self) -> Self;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:39\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":218,"byte_end":236,"line_start":11,"line_end":11,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub header: Header,","highlight_start":5,"highlight_end":23}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":135,"byte_end":140,"line_start":8,"line_end":8,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::clone::Clone::clone`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":8836,"byte_end":8841,"line_start":236,"line_end":236,"column_start":8,"column_end":13,"is_primary":false,"text":[{"text":"    fn clone(&self) -> Self;","highlight_start":8,"highlight_end":13}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs","byte_start":7268,"byte_end":7273,"line_start":194,"line_end":194,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"pub const trait Clone: Sized {","highlight_start":24,"highlight_end":29}],"label":"required by this bound in `Clone::clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:11:5\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub header: Header,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::clone::Clone::clone`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/clone.rs:194:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub const trait Clone: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Clone::clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn clone(&self) -> Self;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:39\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:39\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::option::Option`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24111,"byte_end":24112,"line_start":599,"line_end":599,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Option<T> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Option`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::option::Option`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:599:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m599\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Option<T> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Option`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:39\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::option::Option`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24111,"byte_end":24112,"line_start":599,"line_end":599,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Option<T> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Option`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::option::Option`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:599:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m599\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Option<T> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Option`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:39\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:39\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::option::Option`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24111,"byte_end":24112,"line_start":599,"line_end":599,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Option<T> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Option`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::option::Option`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:599:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m599\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Option<T> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Option`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":157,"byte_end":163,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:39\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::option::Option`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24111,"byte_end":24112,"line_start":599,"line_end":599,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Option<T> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Option`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::option::Option`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:599:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m599\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Option<T> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Option`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::option::Option`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24111,"byte_end":24112,"line_start":599,"line_end":599,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Option<T> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Option`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::option::Option`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:599:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m599\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Option<T> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Option`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::option::Option`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24111,"byte_end":24112,"line_start":599,"line_end":599,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Option<T> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Option`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::option::Option`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:599:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m599\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Option<T> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Option`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::option::Option`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24111,"byte_end":24112,"line_start":599,"line_end":599,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Option<T> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Option`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::option::Option`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:599:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m599\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Option<T> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Option`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::option::Option`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24111,"byte_end":24112,"line_start":599,"line_end":599,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Option<T> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Option`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::option::Option`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:599:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m599\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Option<T> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Option`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the method `is_some` exists for enum `std::option::Option<block::header::Header>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"method cannot be called on `std::option::Option<block::header::Header>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/block/header.rs","byte_start":301,"byte_end":318,"line_start":16,"line_end":16,"column_start":1,"column_end":18,"is_primary":false,"text":[{"text":"pub struct Header {","highlight_start":1,"highlight_end":18}],"label":"doesn't satisfy `block::header::Header: std::marker::Sized`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1174,"byte_end":1197,"line_start":35,"line_end":35,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":1,"highlight_end":24}],"label":"doesn't satisfy `_: KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/single_use.rs","byte_start":713,"byte_end":736,"line_start":18,"line_end":18,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"pub struct SingleUse<T>(pub T);","highlight_start":1,"highlight_end":24}],"label":"doesn't satisfy `_: KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`kes::Sum<kes::Sum<kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\nwhich is required by `block::header::Header: std::marker::Sized`\n`kes::Sum<kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\nwhich is required by `block::header::Header: std::marker::Sized`\n`kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\nwhich is required by `block::header::Header: std::marker::Sized`\n`kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\nwhich is required by `block::header::Header: std::marker::Sized`\n`kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser`\nwhich is required by `block::header::Header: std::marker::Sized`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `is_some` exists for enum `std::option::Option<block::header::Header>`, but its trait bounds were not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `std::option::Option<block::header::Header>` due to unsatisfied trait bounds\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0mledger/src/block/header.rs:16:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-----------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `block::header::Header: std::marker::Sized`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:35:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-----------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/charles/Code/pallas-extras/kes/src/single_use.rs:18:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct SingleUse<T>(pub T);\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-----------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n           `kes::Sum<kes::Sum<kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\n           which is required by `block::header::Header: std::marker::Sized`\n           `kes::Sum<kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\n           which is required by `block::header::Header: std::marker::Sized`\n           `kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\n           which is required by `block::header::Header: std::marker::Sized`\n           `kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\n           which is required by `block::header::Header: std::marker::Sized`\n           `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser`\n           which is required by `block::header::Header: std::marker::Sized`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"expected `Box<[(u16, Data)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(u16, transaction::Data)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91mexpected `Box<[(u16, Data)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(u16, transaction::Data)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::option::Option`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24111,"byte_end":24112,"line_start":599,"line_end":599,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Option<T> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Option`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::option::Option`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:599:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m599\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Option<T> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Option`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by an implicit `Sized` bound in `std::option::Option`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24111,"byte_end":24112,"line_start":599,"line_end":599,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub enum Option<T> {","highlight_start":17,"highlight_end":18}],"label":"required by the implicit `Sized` requirement on this type parameter in `Option`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by an implicit `Sized` bound in `std::option::Option`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:599:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m599\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Option<T> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^\u001b[0m \u001b[1m\u001b[92mrequired by the implicit `Sized` requirement on this type parameter in `Option`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the method `is_some` exists for enum `std::option::Option<block::header::Header>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"method cannot be called on `std::option::Option<block::header::Header>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/block/header.rs","byte_start":301,"byte_end":318,"line_start":16,"line_end":16,"column_start":1,"column_end":18,"is_primary":false,"text":[{"text":"pub struct Header {","highlight_start":1,"highlight_end":18}],"label":"doesn't satisfy `block::header::Header: std::marker::Sized`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/sum.rs","byte_start":1174,"byte_end":1197,"line_start":35,"line_end":35,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"pub struct Sum<L, R, H>","highlight_start":1,"highlight_end":24}],"label":"doesn't satisfy `_: KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/Code/pallas-extras/kes/src/single_use.rs","byte_start":713,"byte_end":736,"line_start":18,"line_end":18,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"pub struct SingleUse<T>(pub T);","highlight_start":1,"highlight_end":24}],"label":"doesn't satisfy `_: KeySizeUser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`kes::Sum<kes::Sum<kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\nwhich is required by `block::header::Header: std::marker::Sized`\n`kes::Sum<kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\nwhich is required by `block::header::Header: std::marker::Sized`\n`kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\nwhich is required by `block::header::Header: std::marker::Sized`\n`kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\nwhich is required by `block::header::Header: std::marker::Sized`\n`kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser`\nwhich is required by `block::header::Header: std::marker::Sized`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `is_some` exists for enum `std::option::Option<block::header::Header>`, but its trait bounds were not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `std::option::Option<block::header::Header>` due to unsatisfied trait bounds\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0mledger/src/block/header.rs:16:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-----------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `block::header::Header: std::marker::Sized`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/charles/Code/pallas-extras/kes/src/sum.rs:35:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Sum<L, R, H>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-----------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/charles/Code/pallas-extras/kes/src/single_use.rs:18:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct SingleUse<T>(pub T);\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-----------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: KeySizeUser`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n           `kes::Sum<kes::Sum<kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\n           which is required by `block::header::Header: std::marker::Sized`\n           `kes::Sum<kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\n           which is required by `block::header::Header: std::marker::Sized`\n           `kes::Sum<kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\n           which is required by `block::header::Header: std::marker::Sized`\n           `kes::Sum<kes::SingleUse<ed25519_dalek::SigningKey>, kes::SingleUse<ed25519_dalek::SigningKey>, blake2::Blake2b<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UInt<digest::typenum::UTerm, digest::typenum::B1>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>, digest::typenum::B0>>>: digest::crypto_common::KeySizeUser`\n           which is required by `block::header::Header: std::marker::Sized`\n           `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser`\n           which is required by `block::header::Header: std::marker::Sized`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:55\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-14055136038096974114.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"expected `Box<[(u16, Data)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(u16, transaction::Data)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":165,"byte_end":171,"line_start":8,"line_end":8,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":47,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91mexpected `Box<[(u16, Data)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(u16, transaction::Data)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:47\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:55\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-17526774424746716432.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:55\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-11663010054130327698.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:55\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:55\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-4cb7cba78aae32f8.long-type-16019624873006198162.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:55\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-6319085905567772983.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:55\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-5240427193355557539.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"2 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:55\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<SingleUse<SigningKey>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 2 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-18127238237803789081.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::Sum<L, R, H>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"3 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>: KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:55\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::Sum<L, R, H>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 3 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":"the trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/block.rs","byte_start":173,"byte_end":180,"line_start":8,"line_end":8,"column_start":55,"column_end":62,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `digest::crypto_common::KeySizeUser` is implemented for `kes::SingleUse<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"4 redundant requirements hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `block::header::Header`","code":null,"level":"note","spans":[{"file_name":"ledger/src/block/header.rs","byte_start":312,"byte_end":318,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Header {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Encode::is_nil`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":632,"byte_end":1936,"line_start":22,"line_end":49,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Encode<C> {","highlight_start":1,"highlight_end":22},{"text":"    /// Encode a value of this type using the given `Encoder`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In addition to the encoder a user provided encoding context is given","highlight_start":1,"highlight_end":77},{"text":"    /// as another parameter. Most implementations of this trait do not need an","highlight_start":1,"highlight_end":80},{"text":"    /// encoding context and should be completely generic in the context","highlight_start":1,"highlight_end":73},{"text":"    /// type. In cases where a context is needed and the `Encode` impl type is","highlight_start":1,"highlight_end":79},{"text":"    /// meant to be combined with other types that require a different context","highlight_start":1,"highlight_end":79},{"text":"    /// type, it is preferrable to constrain the context type variable `C` with","highlight_start":1,"highlight_end":80},{"text":"    /// a trait bound instead of fixing the type.","highlight_start":1,"highlight_end":50},{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":1,"highlight_end":96},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Is this value of `Self` a nil value?","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is primarily used by `minicbor-derive`.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Some types have a special value to denote the concept of \"nothing\", aka","highlight_start":1,"highlight_end":80},{"text":"    /// nil. An example is the `Option` type with its `None` value. This","highlight_start":1,"highlight_end":73},{"text":"    /// method--if overriden--allows checking if a value is such a special nil","highlight_start":1,"highlight_end":79},{"text":"    /// value.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// NB: A type implementing `Encode` with an overriden `Encode::is_nil`","highlight_start":1,"highlight_end":76},{"text":"    /// method should also override `Decode::nil` if it implements `Decode`","highlight_start":1,"highlight_end":76},{"text":"    /// at all.","highlight_start":1,"highlight_end":16},{"text":"    fn is_nil(&self) -> bool {","highlight_start":1,"highlight_end":31},{"text":"        false","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"required by this bound in `Encode::is_nil`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `kes::SingleUse<ed25519_dalek::SigningKey>: digest::crypto_common::KeySizeUser` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block.rs:8:55\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `digest::crypto_common::KeySizeUser` is not implemented for `kes::SingleUse<ed25519_dalek::SigningKey>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `digest::crypto_common::KeySizeUser` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mkes::SingleUse<T>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<SingleUse<SigningKey>, SingleUse<SigningKey>, Blake2b<...>>` to implement `ecdsa::signature::KeypairRef`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 4 redundant requirements hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Sum<Sum<Sum<Sum<..., ..., ...>, ..., ...>, ..., ...>, ..., ...>` to implement `ecdsa::signature::KeypairRef`\n\u001b[1m\u001b[92mnote\u001b[0m: required because it appears within the type `block::header::Header`\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/block/header.rs:16:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Header {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Encode::is_nil`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:22:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait Encode<C> {\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// Encode a value of this type using the given `Encoder`.\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ///\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     /// In addition to the encoder a user provided encoding context is given\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Encode::is_nil`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/charles/Code/pallas-extras/target/debug/deps/ledger-71f650a0639f86bf.long-type-16094129454109675426.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`?` operator has incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/certificate.rs","byte_start":17651,"byte_end":17690,"line_start":459,"line_end":459,"column_start":53,"column_end":92,"is_primary":true,"text":[{"text":"            let value: Box<[(StakeAddress, u64)]> = cbor_util::list_as_map::decode(d, ctx)?;","highlight_start":53,"highlight_end":92}],"label":"expected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected struct `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"call `Into::into` on this expression to convert `std::vec::Vec<(_, _)>` into `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`","code":null,"level":"help","spans":[{"file_name":"ledger/src/certificate.rs","byte_start":17690,"byte_end":17690,"line_start":459,"line_end":459,"column_start":92,"column_end":92,"is_primary":true,"text":[{"text":"            let value: Box<[(StakeAddress, u64)]> = cbor_util::list_as_map::decode(d, ctx)?;","highlight_start":92,"highlight_end":92}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `?` operator has incompatible types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/certificate.rs:459:53\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m459\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let value: Box<[(StakeAddress, u64)]> = cbor_util::list_as_map::decode(d, ctx)?;\n    \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: call `Into::into` on this expression to convert `std::vec::Vec<(_, _)>` into `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m459\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            let value: Box<[(StakeAddress, u64)]> = cbor_util::list_as_map::decode(d, ctx)?\u001b[92m.into()\u001b[0m;\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                            \u001b[92m+++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`?` operator has incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/certificate.rs","byte_start":17651,"byte_end":17690,"line_start":459,"line_end":459,"column_start":53,"column_end":92,"is_primary":true,"text":[{"text":"            let value: Box<[(StakeAddress, u64)]> = cbor_util::list_as_map::decode(d, ctx)?;","highlight_start":53,"highlight_end":92}],"label":"expected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected struct `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"call `Into::into` on this expression to convert `std::vec::Vec<(_, _)>` into `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`","code":null,"level":"help","spans":[{"file_name":"ledger/src/certificate.rs","byte_start":17690,"byte_end":17690,"line_start":459,"line_end":459,"column_start":92,"column_end":92,"is_primary":true,"text":[{"text":"            let value: Box<[(StakeAddress, u64)]> = cbor_util::list_as_map::decode(d, ctx)?;","highlight_start":92,"highlight_end":92}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `?` operator has incompatible types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/certificate.rs:459:53\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m459\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let value: Box<[(StakeAddress, u64)]> = cbor_util::list_as_map::decode(d, ctx)?;\n    \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: call `Into::into` on this expression to convert `std::vec::Vec<(_, _)>` into `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m459\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            let value: Box<[(StakeAddress, u64)]> = cbor_util::list_as_map::decode(d, ctx)?\u001b[92m.into()\u001b[0m;\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                            \u001b[92m+++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/protocol.rs","byte_start":17750,"byte_end":17756,"line_start":463,"line_end":463,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[([u8; 28], ParameterUpdate)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/protocol.rs","byte_start":17750,"byte_end":17756,"line_start":463,"line_end":463,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/protocol.rs","byte_start":17750,"byte_end":17756,"line_start":463,"line_end":463,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/protocol.rs","byte_start":17750,"byte_end":17756,"line_start":463,"line_end":463,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[([u8; 28], protocol::ParameterUpdate)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/protocol.rs","byte_start":17750,"byte_end":17756,"line_start":463,"line_end":463,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/protocol.rs","byte_start":17750,"byte_end":17756,"line_start":463,"line_end":463,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/protocol.rs:463:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m463\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91mexpected `Box<[([u8; 28], ParameterUpdate)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[([u8; 28], protocol::ParameterUpdate)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/protocol.rs:463:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m463\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/protocol.rs","byte_start":17750,"byte_end":17756,"line_start":463,"line_end":463,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[([u8; 28], ParameterUpdate)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/protocol.rs","byte_start":17750,"byte_end":17756,"line_start":463,"line_end":463,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/protocol.rs","byte_start":17750,"byte_end":17756,"line_start":463,"line_end":463,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/protocol.rs","byte_start":17750,"byte_end":17756,"line_start":463,"line_end":463,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[([u8; 28], protocol::ParameterUpdate)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/protocol.rs","byte_start":17750,"byte_end":17756,"line_start":463,"line_end":463,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/protocol.rs","byte_start":17750,"byte_end":17756,"line_start":463,"line_end":463,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/protocol.rs:463:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m463\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91mexpected `Box<[([u8; 28], ParameterUpdate)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[([u8; 28], protocol::ParameterUpdate)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/protocol.rs:463:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m463\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`?` operator has incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":4668,"byte_end":4707,"line_start":134,"line_end":134,"column_start":27,"column_end":66,"is_primary":true,"text":[{"text":"                metadata: cbor_util::list_as_map::decode(d, ctx)?,","highlight_start":27,"highlight_end":66}],"label":"expected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(u64, transaction::Metadatum)]>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected struct `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"call `Into::into` on this expression to convert `std::vec::Vec<(_, _)>` into `std::boxed::Box<[(u64, transaction::Metadatum)]>`","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":4707,"byte_end":4707,"line_start":134,"line_end":134,"column_start":66,"column_end":66,"is_primary":true,"text":[{"text":"                metadata: cbor_util::list_as_map::decode(d, ctx)?,","highlight_start":66,"highlight_end":66}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `?` operator has incompatible types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:134:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m134\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 metadata: cbor_util::list_as_map::decode(d, ctx)?,\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: call `Into::into` on this expression to convert `std::vec::Vec<(_, _)>` into `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m134\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                metadata: cbor_util::list_as_map::decode(d, ctx)?\u001b[92m.into()\u001b[0m,\n    \u001b[1m\u001b[94m|\u001b[0m                                                                  \u001b[92m+++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"expected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:82:26\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91mexpected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:82:26\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"expected `Option<Box<[(u64, Metadatum)]>>`, found `Option<Vec<(_, _)>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `std::option::Option<std::boxed::Box<[(u64, transaction::Metadatum)]>>`\n   found enum `std::option::Option<std::vec::Vec<(_, _)>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:82:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Box<[(u64, Metadatum)]>>`, found `Option<Vec<(_, _)>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::option::Option<std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m>`\n              found enum `std::option::Option<std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"expected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:82:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m`\n              found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"expected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:115:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m115\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91mexpected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:115:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m115\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"expected `Option<Box<[(u64, Metadatum)]>>`, found `Option<Vec<(_, _)>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `std::option::Option<std::boxed::Box<[(u64, transaction::Metadatum)]>>`\n   found enum `std::option::Option<std::vec::Vec<(_, _)>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:115:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m115\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Box<[(u64, Metadatum)]>>`, found `Option<Vec<(_, _)>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::option::Option<std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m>`\n               found enum `std::option::Option<std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"expected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:115:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m115\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`?` operator has incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":4668,"byte_end":4707,"line_start":134,"line_end":134,"column_start":27,"column_end":66,"is_primary":true,"text":[{"text":"                metadata: cbor_util::list_as_map::decode(d, ctx)?,","highlight_start":27,"highlight_end":66}],"label":"expected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(u64, transaction::Metadatum)]>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected struct `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"call `Into::into` on this expression to convert `std::vec::Vec<(_, _)>` into `std::boxed::Box<[(u64, transaction::Metadatum)]>`","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":4707,"byte_end":4707,"line_start":134,"line_end":134,"column_start":66,"column_end":66,"is_primary":true,"text":[{"text":"                metadata: cbor_util::list_as_map::decode(d, ctx)?,","highlight_start":66,"highlight_end":66}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `?` operator has incompatible types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:134:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m134\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 metadata: cbor_util::list_as_map::decode(d, ctx)?,\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: call `Into::into` on this expression to convert `std::vec::Vec<(_, _)>` into `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m134\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                metadata: cbor_util::list_as_map::decode(d, ctx)?\u001b[92m.into()\u001b[0m,\n    \u001b[1m\u001b[94m|\u001b[0m                                                                  \u001b[92m+++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"expected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:82:26\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91mexpected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:82:26\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"expected `Option<Box<[(u64, Metadatum)]>>`, found `Option<Vec<(_, _)>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `std::option::Option<std::boxed::Box<[(u64, transaction::Metadatum)]>>`\n   found enum `std::option::Option<std::vec::Vec<(_, _)>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:82:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Box<[(u64, Metadatum)]>>`, found `Option<Vec<(_, _)>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::option::Option<std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m>`\n              found enum `std::option::Option<std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`?` operator has incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":6626,"byte_end":6665,"line_start":190,"line_end":190,"column_start":35,"column_end":74,"is_primary":true,"text":[{"text":"                Ok(Metadatum::Map(cbor_util::list_as_map::decode(d, ctx)?))","highlight_start":35,"highlight_end":74}],"label":"expected `Box<[(Metadatum, Metadatum)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(transaction::Metadatum, transaction::Metadatum)]>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected struct `std::boxed::Box<[(transaction::Metadatum, transaction::Metadatum)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"call `Into::into` on this expression to convert `std::vec::Vec<(_, _)>` into `std::boxed::Box<[(transaction::Metadatum, transaction::Metadatum)]>`","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":6665,"byte_end":6665,"line_start":190,"line_end":190,"column_start":74,"column_end":74,"is_primary":true,"text":[{"text":"                Ok(Metadatum::Map(cbor_util::list_as_map::decode(d, ctx)?))","highlight_start":74,"highlight_end":74}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `?` operator has incompatible types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:190:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m190\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 Ok(Metadatum::Map(cbor_util::list_as_map::decode(d, ctx)?))\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(Metadatum, Metadatum)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(transaction::Metadatum, transaction::Metadatum)]>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(transaction::Metadatum, transaction::Metadatum)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: call `Into::into` on this expression to convert `std::vec::Vec<(_, _)>` into `std::boxed::Box<[(transaction::Metadatum, transaction::Metadatum)]>`\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m190\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                Ok(Metadatum::Map(cbor_util::list_as_map::decode(d, ctx)?\u001b[92m.into()\u001b[0m))\n    \u001b[1m\u001b[94m|\u001b[0m                                                                          \u001b[92m+++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"expected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":2622,"byte_end":2628,"line_start":82,"line_end":82,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:82:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m`\n              found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"expected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:115:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m115\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91mexpected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:115:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m115\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"expected `Option<Box<[(u64, Metadatum)]>>`, found `Option<Vec<(_, _)>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `std::option::Option<std::boxed::Box<[(u64, transaction::Metadatum)]>>`\n   found enum `std::option::Option<std::vec::Vec<(_, _)>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:115:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m115\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Box<[(u64, Metadatum)]>>`, found `Option<Vec<(_, _)>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::option::Option<std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m>`\n               found enum `std::option::Option<std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"expected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":3961,"byte_end":3967,"line_start":115,"line_end":115,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(u64, transaction::Metadatum)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:115:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m115\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(u64, Metadatum)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(u64, transaction::Metadatum)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91mexpected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`?` operator has incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":6626,"byte_end":6665,"line_start":190,"line_end":190,"column_start":35,"column_end":74,"is_primary":true,"text":[{"text":"                Ok(Metadatum::Map(cbor_util::list_as_map::decode(d, ctx)?))","highlight_start":35,"highlight_end":74}],"label":"expected `Box<[(Metadatum, Metadatum)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(transaction::Metadatum, transaction::Metadatum)]>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected struct `std::boxed::Box<[(transaction::Metadatum, transaction::Metadatum)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"call `Into::into` on this expression to convert `std::vec::Vec<(_, _)>` into `std::boxed::Box<[(transaction::Metadatum, transaction::Metadatum)]>`","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":6665,"byte_end":6665,"line_start":190,"line_end":190,"column_start":74,"column_end":74,"is_primary":true,"text":[{"text":"                Ok(Metadatum::Map(cbor_util::list_as_map::decode(d, ctx)?))","highlight_start":74,"highlight_end":74}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `?` operator has incompatible types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:190:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m190\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 Ok(Metadatum::Map(cbor_util::list_as_map::decode(d, ctx)?))\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(Metadatum, Metadatum)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(transaction::Metadatum, transaction::Metadatum)]>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(transaction::Metadatum, transaction::Metadatum)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: call `Into::into` on this expression to convert `std::vec::Vec<(_, _)>` into `std::boxed::Box<[(transaction::Metadatum, transaction::Metadatum)]>`\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m190\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                Ok(Metadatum::Map(cbor_util::list_as_map::decode(d, ctx)?\u001b[92m.into()\u001b[0m))\n    \u001b[1m\u001b[94m|\u001b[0m                                                                          \u001b[92m+++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Option<Box<[(StakeAddress, u64)]>>`, found `Option<Vec<(_, _)>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `std::option::Option<std::boxed::Box<[(address::shelley::StakeAddress, u64)]>>`\n   found enum `std::option::Option<std::vec::Vec<(_, _)>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Box<[(StakeAddress, u64)]>>`, found `Option<Vec<(_, _)>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::option::Option<std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m>`\n               found enum `std::option::Option<std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(Voter, Set)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(governance::voting::Voter, governance::voting::Set)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91mexpected `Box<[(Voter, Set)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(governance::voting::Voter, governance::voting::Set)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Option<Box<[(Voter, Set)]>>`, found `Option<Vec<(_, _)>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `std::option::Option<std::boxed::Box<[(governance::voting::Voter, governance::voting::Set)]>>`\n   found enum `std::option::Option<std::vec::Vec<(_, _)>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Box<[(Voter, Set)]>>`, found `Option<Vec<(_, _)>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::option::Option<std::\u001b[1m\u001b[35mboxed::Box<[(governance::voting::Voter, governance::voting::Set)]>\u001b[0m>`\n               found enum `std::option::Option<std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91mexpected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Option<Box<[(StakeAddress, u64)]>>`, found `Option<Vec<(_, _)>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `std::option::Option<std::boxed::Box<[(address::shelley::StakeAddress, u64)]>>`\n   found enum `std::option::Option<std::vec::Vec<(_, _)>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Box<[(StakeAddress, u64)]>>`, found `Option<Vec<(_, _)>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::option::Option<std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m>`\n               found enum `std::option::Option<std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(Voter, Set)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(governance::voting::Voter, governance::voting::Set)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(Voter, Set)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(governance::voting::Voter, governance::voting::Set)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(Voter, Set)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(governance::voting::Voter, governance::voting::Set)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91mexpected `Box<[(Voter, Set)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(governance::voting::Voter, governance::voting::Set)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Option<Box<[(Voter, Set)]>>`, found `Option<Vec<(_, _)>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `std::option::Option<std::boxed::Box<[(governance::voting::Voter, governance::voting::Set)]>>`\n   found enum `std::option::Option<std::vec::Vec<(_, _)>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Box<[(Voter, Set)]>>`, found `Option<Vec<(_, _)>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::option::Option<std::\u001b[1m\u001b[35mboxed::Box<[(governance::voting::Voter, governance::voting::Set)]>\u001b[0m>`\n               found enum `std::option::Option<std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `address::Address: minicbor::Encode<Ctx>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":9538,"byte_end":9544,"line_start":267,"line_end":267,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":9538,"byte_end":9544,"line_start":267,"line_end":267,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `minicbor::Encode<Ctx>` is not implemented for `address::Address`","code":null,"level":"help","spans":[{"file_name":"ledger/src/address.rs","byte_start":209,"byte_end":225,"line_start":10,"line_end":10,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Address {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider introducing a `where` clause, but there might be an alternative better way to express this requirement","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":9586,"byte_end":9586,"line_start":269,"line_end":269,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Output {","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":" where address::Address: minicbor::Encode<Ctx>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `address::Address: minicbor::Encode<Ctx>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:267:62\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m267\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Encode<Ctx>` is not implemented for `address::Address`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/address.rs:10:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Address {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\u001b[1m\u001b[96mhelp\u001b[0m: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m269\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub struct Output\u001b[92m where address::Address: minicbor::Encode<Ctx>\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[92m+++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":9538,"byte_end":9544,"line_start":267,"line_end":267,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"expected `&mut Era`, found `&mut Ctx`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":9538,"byte_end":9544,"line_start":267,"line_end":267,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/transaction.rs","byte_start":9538,"byte_end":9544,"line_start":267,"line_end":267,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":9538,"byte_end":9544,"line_start":267,"line_end":267,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected mutable reference `&mut protocol::Era`\n   found mutable reference `&mut Ctx`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":1250,"byte_end":1256,"line_start":32,"line_end":32,"column_start":8,"column_end":14,"is_primary":true,"text":[{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":8,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:267:62\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m267\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91mexpected `&mut Era`, found `&mut Ctx`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected mutable reference `&mut \u001b[1m\u001b[35mprotocol::Era\u001b[0m`\n               found mutable reference `&mut \u001b[1m\u001b[35mCtx\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:32:8\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `address::Address: minicbor::Encode<Ctx>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":9546,"byte_end":9553,"line_start":267,"line_end":267,"column_start":70,"column_end":77,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":70,"highlight_end":77}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":9546,"byte_end":9553,"line_start":267,"line_end":267,"column_start":70,"column_end":77,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":70,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `minicbor::Encode<Ctx>` is not implemented for `address::Address`","code":null,"level":"help","spans":[{"file_name":"ledger/src/address.rs","byte_start":209,"byte_end":225,"line_start":10,"line_end":10,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Address {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider introducing a `where` clause, but there might be an alternative better way to express this requirement","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":9586,"byte_end":9586,"line_start":269,"line_end":269,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Output {","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":" where address::Address: minicbor::Encode<Ctx>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `address::Address: minicbor::Encode<Ctx>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:267:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m267\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Encode<Ctx>` is not implemented for `address::Address`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/address.rs:10:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Address {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\u001b[1m\u001b[96mhelp\u001b[0m: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m269\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub struct Output\u001b[92m where address::Address: minicbor::Encode<Ctx>\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[92m+++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(Voter, Set)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":7418,"byte_end":7424,"line_start":210,"line_end":210,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(governance::voting::Voter, governance::voting::Set)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:210:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(Voter, Set)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(governance::voting::Voter, governance::voting::Set)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `address::Address: minicbor::Decode<'_, ()>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":10247,"byte_end":10253,"line_start":289,"line_end":289,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"                            address: d.decode()?,","highlight_start":40,"highlight_end":46}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Decode<'_, ()>` is not implemented for `address::Address`\nbut trait `Decode<'_, protocol::Era>` is implemented for it","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for that trait implementation, expected `protocol::Era`, found `()`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Decoder::<'b>::decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode/decoder.rs","byte_start":580,"byte_end":594,"line_start":22,"line_end":22,"column_start":22,"column_end":36,"is_primary":true,"text":[{"text":"    pub fn decode<T: Decode<'b, ()>>(&mut self) -> Result<T, Error> {","highlight_start":22,"highlight_end":36}],"label":"required by this bound in `Decoder::<'b>::decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `address::Address: minicbor::Decode<'_, ()>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:289:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m289\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   address: d.decode()?,\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `Decode<'_, \u001b[1m\u001b[35m()\u001b[0m>` \u001b[1m\u001b[35mis not\u001b[0m implemented for `address::Address`\n            but trait `Decode<'_, \u001b[1m\u001b[35mprotocol::Era\u001b[0m>` \u001b[1m\u001b[35mis\u001b[0m implemented for it\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: for that trait implementation, expected `\u001b[1m\u001b[35mprotocol::Era\u001b[0m`, found `\u001b[1m\u001b[35m()\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Decoder::<'b>::decode`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode/decoder.rs:22:22\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn decode<T: Decode<'b, ()>>(&mut self) -> Result<T, Error> {\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Decoder::<'b>::decode`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `address::Address: minicbor::Decode<'_, Ctx>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":11355,"byte_end":11361,"line_start":314,"line_end":314,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":11355,"byte_end":11361,"line_start":314,"line_end":314,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `minicbor::Decode<'_, Ctx>` is not implemented for `address::Address`","code":null,"level":"help","spans":[{"file_name":"ledger/src/address.rs","byte_start":209,"byte_end":225,"line_start":10,"line_end":10,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Address {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider introducing a `where` clause, but there might be an alternative better way to express this requirement","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":11429,"byte_end":11429,"line_start":316,"line_end":316,"column_start":37,"column_end":37,"is_primary":true,"text":[{"text":"                struct BabbageOutput {","highlight_start":37,"highlight_end":37}],"label":null,"suggested_replacement":" where address::Address: minicbor::Decode<'_, Ctx>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `address::Address: minicbor::Decode<'_, Ctx>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:314:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m314\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Decode<'_, Ctx>` is not implemented for `address::Address`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/address.rs:10:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Address {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\u001b[1m\u001b[96mhelp\u001b[0m: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m316\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                struct BabbageOutput\u001b[92m where address::Address: minicbor::Decode<'_, Ctx>\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[92m+++++++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `address::Address: minicbor::Decode<'_, Ctx>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":11493,"byte_end":11500,"line_start":318,"line_end":318,"column_start":34,"column_end":41,"is_primary":true,"text":[{"text":"                    pub address: Address,","highlight_start":34,"highlight_end":41}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `minicbor::Decode<'_, Ctx>` is not implemented for `address::Address`","code":null,"level":"help","spans":[{"file_name":"ledger/src/address.rs","byte_start":209,"byte_end":225,"line_start":10,"line_end":10,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Address {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider introducing a `where` clause, but there might be an alternative better way to express this requirement","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":11429,"byte_end":11429,"line_start":316,"line_end":316,"column_start":37,"column_end":37,"is_primary":true,"text":[{"text":"                struct BabbageOutput {","highlight_start":37,"highlight_end":37}],"label":null,"suggested_replacement":" where address::Address: minicbor::Decode<'_, Ctx>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `address::Address: minicbor::Decode<'_, Ctx>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:318:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m318\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     pub address: Address,\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Decode<'_, Ctx>` is not implemented for `address::Address`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/address.rs:10:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Address {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m316\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                struct BabbageOutput\u001b[92m where address::Address: minicbor::Decode<'_, Ctx>\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[92m+++++++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `address::Address: minicbor::Encode<Ctx>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":9538,"byte_end":9544,"line_start":267,"line_end":267,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":9538,"byte_end":9544,"line_start":267,"line_end":267,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `minicbor::Encode<Ctx>` is not implemented for `address::Address`","code":null,"level":"help","spans":[{"file_name":"ledger/src/address.rs","byte_start":209,"byte_end":225,"line_start":10,"line_end":10,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Address {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider introducing a `where` clause, but there might be an alternative better way to express this requirement","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":9586,"byte_end":9586,"line_start":269,"line_end":269,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Output {","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":" where address::Address: minicbor::Encode<Ctx>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `address::Address: minicbor::Encode<Ctx>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:267:62\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m267\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Encode<Ctx>` is not implemented for `address::Address`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/address.rs:10:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Address {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\u001b[1m\u001b[96mhelp\u001b[0m: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m269\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub struct Output\u001b[92m where address::Address: minicbor::Encode<Ctx>\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[92m+++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":9538,"byte_end":9544,"line_start":267,"line_end":267,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"expected `&mut Era`, found `&mut Ctx`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":9538,"byte_end":9544,"line_start":267,"line_end":267,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/transaction.rs","byte_start":9538,"byte_end":9544,"line_start":267,"line_end":267,"column_start":62,"column_end":68,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":9538,"byte_end":9544,"line_start":267,"line_end":267,"column_start":62,"column_end":68,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":62,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Encode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19946,"byte_end":20025,"line_start":538,"line_end":538,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected mutable reference `&mut protocol::Era`\n   found mutable reference `&mut Ctx`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs","byte_start":1250,"byte_end":1256,"line_start":32,"line_end":32,"column_start":8,"column_end":14,"is_primary":true,"text":[{"text":"    fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;","highlight_start":8,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:267:62\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m267\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91mexpected `&mut Era`, found `&mut Ctx`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected mutable reference `&mut \u001b[1m\u001b[35mprotocol::Era\u001b[0m`\n               found mutable reference `&mut \u001b[1m\u001b[35mCtx\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/encode.rs:32:8\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn encode<W: Write>(&self, e: &mut Encoder<W>, ctx: &mut C) -> Result<(), Error<W::Error>>;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Encode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `address::Address: minicbor::Encode<Ctx>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":9546,"byte_end":9553,"line_start":267,"line_end":267,"column_start":70,"column_end":77,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":70,"highlight_end":77}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":9546,"byte_end":9553,"line_start":267,"line_end":267,"column_start":70,"column_end":77,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]","highlight_start":70,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CborLen)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":20325,"byte_end":20406,"line_start":553,"line_end":553,"column_start":1,"column_end":82,"is_primary":false,"text":[{"text":"pub fn derive_cbor_len(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `minicbor::Encode<Ctx>` is not implemented for `address::Address`","code":null,"level":"help","spans":[{"file_name":"ledger/src/address.rs","byte_start":209,"byte_end":225,"line_start":10,"line_end":10,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Address {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider introducing a `where` clause, but there might be an alternative better way to express this requirement","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":9586,"byte_end":9586,"line_start":269,"line_end":269,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Output {","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":" where address::Address: minicbor::Encode<Ctx>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `address::Address: minicbor::Encode<Ctx>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:267:70\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m267\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Encode<Ctx>` is not implemented for `address::Address`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/address.rs:10:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Address {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `CborLen` (in Nightly builds, run with -Z macro-backtrace for more info)\n\u001b[1m\u001b[96mhelp\u001b[0m: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m269\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub struct Output\u001b[92m where address::Address: minicbor::Encode<Ctx>\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[92m+++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `address::Address: minicbor::Decode<'_, ()>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":10247,"byte_end":10253,"line_start":289,"line_end":289,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"                            address: d.decode()?,","highlight_start":40,"highlight_end":46}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Decode<'_, ()>` is not implemented for `address::Address`\nbut trait `Decode<'_, protocol::Era>` is implemented for it","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for that trait implementation, expected `protocol::Era`, found `()`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::Decoder::<'b>::decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode/decoder.rs","byte_start":580,"byte_end":594,"line_start":22,"line_end":22,"column_start":22,"column_end":36,"is_primary":true,"text":[{"text":"    pub fn decode<T: Decode<'b, ()>>(&mut self) -> Result<T, Error> {","highlight_start":22,"highlight_end":36}],"label":"required by this bound in `Decoder::<'b>::decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `address::Address: minicbor::Decode<'_, ()>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:289:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m289\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   address: d.decode()?,\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `Decode<'_, \u001b[1m\u001b[35m()\u001b[0m>` \u001b[1m\u001b[35mis not\u001b[0m implemented for `address::Address`\n            but trait `Decode<'_, \u001b[1m\u001b[35mprotocol::Era\u001b[0m>` \u001b[1m\u001b[35mis\u001b[0m implemented for it\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: for that trait implementation, expected `\u001b[1m\u001b[35mprotocol::Era\u001b[0m`, found `\u001b[1m\u001b[35m()\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::Decoder::<'b>::decode`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/decode/decoder.rs:22:22\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn decode<T: Decode<'b, ()>>(&mut self) -> Result<T, Error> {\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Decoder::<'b>::decode`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `address::Address: minicbor::Decode<'_, Ctx>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":11355,"byte_end":11361,"line_start":314,"line_end":314,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/transaction.rs","byte_start":11355,"byte_end":11361,"line_start":314,"line_end":314,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                #[derive(Decode)]","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `minicbor::Decode<'_, Ctx>` is not implemented for `address::Address`","code":null,"level":"help","spans":[{"file_name":"ledger/src/address.rs","byte_start":209,"byte_end":225,"line_start":10,"line_end":10,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Address {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider introducing a `where` clause, but there might be an alternative better way to express this requirement","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":11429,"byte_end":11429,"line_start":316,"line_end":316,"column_start":37,"column_end":37,"is_primary":true,"text":[{"text":"                struct BabbageOutput {","highlight_start":37,"highlight_end":37}],"label":null,"suggested_replacement":" where address::Address: minicbor::Decode<'_, Ctx>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `address::Address: minicbor::Decode<'_, Ctx>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:314:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m314\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 #[derive(Decode)]\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Decode<'_, Ctx>` is not implemented for `address::Address`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/address.rs:10:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Address {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\u001b[1m\u001b[96mhelp\u001b[0m: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m316\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                struct BabbageOutput\u001b[92m where address::Address: minicbor::Decode<'_, Ctx>\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[92m+++++++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `address::Address: minicbor::Decode<'_, Ctx>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":11493,"byte_end":11500,"line_start":318,"line_end":318,"column_start":34,"column_end":41,"is_primary":true,"text":[{"text":"                    pub address: Address,","highlight_start":34,"highlight_end":41}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `minicbor::Decode<'_, Ctx>` is not implemented for `address::Address`","code":null,"level":"help","spans":[{"file_name":"ledger/src/address.rs","byte_start":209,"byte_end":225,"line_start":10,"line_end":10,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Address {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider introducing a `where` clause, but there might be an alternative better way to express this requirement","code":null,"level":"help","spans":[{"file_name":"ledger/src/transaction.rs","byte_start":11429,"byte_end":11429,"line_start":316,"line_end":316,"column_start":37,"column_end":37,"is_primary":true,"text":[{"text":"                struct BabbageOutput {","highlight_start":37,"highlight_end":37}],"label":null,"suggested_replacement":" where address::Address: minicbor::Decode<'_, Ctx>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `address::Address: minicbor::Decode<'_, Ctx>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/transaction.rs:318:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m318\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     pub address: Address,\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Decode<'_, Ctx>` is not implemented for `address::Address`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/address.rs:10:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Address {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m316\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                struct BabbageOutput\u001b[92m where address::Address: minicbor::Decode<'_, Ctx>\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[92m+++++++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/action.rs:14:70\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91mexpected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/action.rs:14:70\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Option<Box<[(StakeAddress, u64)]>>`, found `Option<Vec<(_, _)>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `std::option::Option<std::boxed::Box<[(address::shelley::StakeAddress, u64)]>>`\n   found enum `std::option::Option<std::vec::Vec<(_, _)>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/action.rs:14:70\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Box<[(StakeAddress, u64)]>>`, found `Option<Vec<(_, _)>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::option::Option<std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m>`\n              found enum `std::option::Option<std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/action.rs:14:70\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m`\n              found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(Credential, u64)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(credential::Credential, u64)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/action.rs:14:70\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91mexpected `Box<[(Credential, u64)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(credential::Credential, u64)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/action.rs:14:70\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/action.rs:14:70\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91mexpected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/action.rs:14:70\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Option<Box<[(StakeAddress, u64)]>>`, found `Option<Vec<(_, _)>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `std::option::Option<std::boxed::Box<[(address::shelley::StakeAddress, u64)]>>`\n   found enum `std::option::Option<std::vec::Vec<(_, _)>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/action.rs:14:70\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Box<[(StakeAddress, u64)]>>`, found `Option<Vec<(_, _)>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::option::Option<std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m>`\n              found enum `std::option::Option<std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(address::shelley::StakeAddress, u64)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/action.rs:14:70\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(StakeAddress, u64)]>`, found `Vec<(_, _)>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(address::shelley::StakeAddress, u64)]>\u001b[0m`\n              found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(Credential, u64)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `std::boxed::Box<[(credential::Credential, u64)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/action.rs","byte_start":312,"byte_end":318,"line_start":14,"line_end":14,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/action.rs:14:70\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91mexpected `Box<[(Credential, u64)]>`, found `Vec<(_, _)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(credential::Credential, u64)]>\u001b[0m`\n               found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `std::vec::Vec<(_, _)>` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/action.rs:14:70\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[96m^^^^^^\u001b[0m \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:607:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m607\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`?` operator has incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/governance/voting.rs","byte_start":382,"byte_end":388,"line_start":15,"line_end":15,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(Id, Procedure)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/voting.rs","byte_start":382,"byte_end":388,"line_start":15,"line_end":15,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"`?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(governance::action::Id, governance::voting::Procedure)]>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected struct `std::boxed::Box<[(governance::action::Id, governance::voting::Procedure)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `?` operator has incompatible types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/voting.rs:15:70\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(Id, Procedure)]>`, found `Vec<(_, _)>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(governance::action::Id, governance::voting::Procedure)]>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(governance::action::Id, governance::voting::Procedure)]>\u001b[0m`\n              found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`?` operator has incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"ledger/src/governance/voting.rs","byte_start":382,"byte_end":388,"line_start":15,"line_end":15,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":"expected `Box<[(Id, Procedure)]>`, found `Vec<(_, _)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ledger/src/governance/voting.rs","byte_start":382,"byte_end":388,"line_start":15,"line_end":15,"column_start":70,"column_end":76,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Decode)]","def_site_span":{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-derive-0.18.3/src/lib.rs","byte_start":19664,"byte_end":19743,"line_start":530,"line_end":530,"column_start":1,"column_end":80,"is_primary":false,"text":[{"text":"pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"`?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(governance::action::Id, governance::voting::Procedure)]>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected struct `std::boxed::Box<[(governance::action::Id, governance::voting::Procedure)]>`\n   found struct `std::vec::Vec<(_, _)>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `?` operator has incompatible types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mledger/src/governance/voting.rs:15:70\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encode, Decode, CborLen)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<[(Id, Procedure)]>`, found `Vec<(_, _)>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `?` operator cannot convert from `std::vec::Vec<(_, _)>` to `std::boxed::Box<[(governance::action::Id, governance::voting::Procedure)]>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `std::\u001b[1m\u001b[35mboxed::Box<[(governance::action::Id, governance::voting::Procedure)]>\u001b[0m`\n              found struct `std::\u001b[1m\u001b[35mvec::Vec<(_, _)>\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Decode` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `byron::Payload: minicbor::Encode<()>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1158,"byte_end":1165,"line_start":34,"line_end":34,"column_start":45,"column_end":52,"is_primary":true,"text":[{"text":"        let cbor_payload = minicbor::to_vec(payload)","highlight_start":45,"highlight_end":52}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":1141,"byte_end":1157,"line_start":34,"line_end":34,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"        let cbor_payload = minicbor::to_vec(payload)","highlight_start":28,"highlight_end":44}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `minicbor::Encode<()>` is not implemented for `byron::Payload`","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1861,"byte_end":1875,"line_start":54,"line_end":54,"column_start":1,"column_end":15,"is_primary":true,"text":[{"text":"struct Payload {","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following other types implement trait `minicbor::Encode<C>`:\n  `&T` implements `minicbor::Encode<C>`\n  `&mut T` implements `minicbor::Encode<C>`\n  `()` implements `minicbor::Encode<C>`\n  `(A, B)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C, D)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C, D, E)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C, D, E, F)` implements `minicbor::Encode<Ctx>`\nand 153 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::to_vec`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","byte_start":6104,"byte_end":6110,"line_start":210,"line_end":210,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"pub fn to_vec<T>(x: T) -> Result<Vec<u8>, encode::Error<Infallible>>","highlight_start":8,"highlight_end":14}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","byte_start":6179,"byte_end":6189,"line_start":212,"line_end":212,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"    T: Encode<()>","highlight_start":8,"highlight_end":18}],"label":"required by this bound in `to_vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `byron::Payload: minicbor::Encode<()>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:34:45\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let cbor_payload = minicbor::to_vec(payload)\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Encode<()>` is not implemented for `byron::Payload`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:54:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m struct Payload {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `minicbor::Encode<C>`:\n              `&T` implements `minicbor::Encode<C>`\n              `&mut T` implements `minicbor::Encode<C>`\n              `()` implements `minicbor::Encode<C>`\n              `(A, B)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C, D)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C, D, E)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C, D, E, F)` implements `minicbor::Encode<Ctx>`\n            and 153 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::to_vec`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs:212:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn to_vec<T>(x: T) -> Result<Vec<u8>, encode::Error<Infallible>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m212\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     T: Encode<()>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `to_vec`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `byron::Address: minicbor::Decode<'_, ()>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1486,"byte_end":1510,"line_start":42,"line_end":42,"column_start":20,"column_end":44,"is_primary":true,"text":[{"text":"        let addr = minicbor::decode(&bytes)?;","highlight_start":20,"highlight_end":44}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `minicbor::Decode<'_, ()>` is not implemented for `byron::Address`","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":116,"byte_end":134,"line_start":3,"line_end":3,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"pub struct Address {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following other types implement trait `minicbor::Decode<'b, C>`:\n  `&'a minicbor::bytes::ByteSlice` implements `minicbor::Decode<'b, C>`\n  `&'a std::ffi::CStr` implements `minicbor::Decode<'b, C>`\n  `&'a std::path::Path` implements `minicbor::Decode<'b, C>`\n  `&'a str` implements `minicbor::Decode<'b, C>`\n  `()` implements `minicbor::Decode<'b, C>`\n  `(A, B)` implements `minicbor::Decode<'b, Ctx>`\n  `(A, B, C)` implements `minicbor::Decode<'b, Ctx>`\n  `(A, B, C, D)` implements `minicbor::Decode<'b, Ctx>`\nand 148 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","byte_start":5113,"byte_end":5119,"line_start":173,"line_end":173,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"pub fn decode<'b, T>(b: &'b [u8]) -> Result<T, decode::Error>","highlight_start":8,"highlight_end":14}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","byte_start":5181,"byte_end":5195,"line_start":175,"line_end":175,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    T: Decode<'b, ()>","highlight_start":8,"highlight_end":22}],"label":"required by this bound in `decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `byron::Address: minicbor::Decode<'_, ()>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:42:20\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let addr = minicbor::decode(&bytes)?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Decode<'_, ()>` is not implemented for `byron::Address`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:3:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Address {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `minicbor::Decode<'b, C>`:\n              `&'a minicbor::bytes::ByteSlice` implements `minicbor::Decode<'b, C>`\n              `&'a std::ffi::CStr` implements `minicbor::Decode<'b, C>`\n              `&'a std::path::Path` implements `minicbor::Decode<'b, C>`\n              `&'a str` implements `minicbor::Decode<'b, C>`\n              `()` implements `minicbor::Decode<'b, C>`\n              `(A, B)` implements `minicbor::Decode<'b, Ctx>`\n              `(A, B, C)` implements `minicbor::Decode<'b, Ctx>`\n              `(A, B, C, D)` implements `minicbor::Decode<'b, Ctx>`\n            and 148 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::decode`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs:175:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m173\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn decode<'b, T>(b: &'b [u8]) -> Result<T, decode::Error>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m174\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m175\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     T: Decode<'b, ()>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `decode`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `byron::Address: minicbor::Encode<()>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1614,"byte_end":1618,"line_start":47,"line_end":47,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"        let bytes = minicbor::to_vec(self)","highlight_start":38,"highlight_end":42}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":1597,"byte_end":1613,"line_start":47,"line_end":47,"column_start":21,"column_end":37,"is_primary":false,"text":[{"text":"        let bytes = minicbor::to_vec(self)","highlight_start":21,"highlight_end":37}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `minicbor::Encode<()>` is not implemented for `byron::Address`","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":116,"byte_end":134,"line_start":3,"line_end":3,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"pub struct Address {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following other types implement trait `minicbor::Encode<C>`:\n  `&T` implements `minicbor::Encode<C>`\n  `&mut T` implements `minicbor::Encode<C>`\n  `()` implements `minicbor::Encode<C>`\n  `(A, B)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C, D)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C, D, E)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C, D, E, F)` implements `minicbor::Encode<Ctx>`\nand 153 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&byron::Address` to implement `minicbor::Encode<()>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::to_vec`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","byte_start":6104,"byte_end":6110,"line_start":210,"line_end":210,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"pub fn to_vec<T>(x: T) -> Result<Vec<u8>, encode::Error<Infallible>>","highlight_start":8,"highlight_end":14}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","byte_start":6179,"byte_end":6189,"line_start":212,"line_end":212,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"    T: Encode<()>","highlight_start":8,"highlight_end":18}],"label":"required by this bound in `to_vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `byron::Address: minicbor::Encode<()>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:47:38\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let bytes = minicbor::to_vec(self)\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Encode<()>` is not implemented for `byron::Address`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:3:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Address {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `minicbor::Encode<C>`:\n              `&T` implements `minicbor::Encode<C>`\n              `&mut T` implements `minicbor::Encode<C>`\n              `()` implements `minicbor::Encode<C>`\n              `(A, B)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C, D)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C, D, E)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C, D, E, F)` implements `minicbor::Encode<Ctx>`\n            and 153 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&byron::Address` to implement `minicbor::Encode<()>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::to_vec`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs:212:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn to_vec<T>(x: T) -> Result<Vec<u8>, encode::Error<Infallible>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m212\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     T: Encode<()>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `to_vec`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `byron::Payload: minicbor::Encode<()>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1158,"byte_end":1165,"line_start":34,"line_end":34,"column_start":45,"column_end":52,"is_primary":true,"text":[{"text":"        let cbor_payload = minicbor::to_vec(payload)","highlight_start":45,"highlight_end":52}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":1141,"byte_end":1157,"line_start":34,"line_end":34,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"        let cbor_payload = minicbor::to_vec(payload)","highlight_start":28,"highlight_end":44}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `minicbor::Encode<()>` is not implemented for `byron::Payload`","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1861,"byte_end":1875,"line_start":54,"line_end":54,"column_start":1,"column_end":15,"is_primary":true,"text":[{"text":"struct Payload {","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following other types implement trait `minicbor::Encode<C>`:\n  `&T` implements `minicbor::Encode<C>`\n  `&mut T` implements `minicbor::Encode<C>`\n  `()` implements `minicbor::Encode<C>`\n  `(A, B)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C, D)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C, D, E)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C, D, E, F)` implements `minicbor::Encode<Ctx>`\nand 153 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::to_vec`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","byte_start":6104,"byte_end":6110,"line_start":210,"line_end":210,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"pub fn to_vec<T>(x: T) -> Result<Vec<u8>, encode::Error<Infallible>>","highlight_start":8,"highlight_end":14}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","byte_start":6179,"byte_end":6189,"line_start":212,"line_end":212,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"    T: Encode<()>","highlight_start":8,"highlight_end":18}],"label":"required by this bound in `to_vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `byron::Payload: minicbor::Encode<()>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:34:45\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let cbor_payload = minicbor::to_vec(payload)\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Encode<()>` is not implemented for `byron::Payload`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:54:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m struct Payload {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `minicbor::Encode<C>`:\n              `&T` implements `minicbor::Encode<C>`\n              `&mut T` implements `minicbor::Encode<C>`\n              `()` implements `minicbor::Encode<C>`\n              `(A, B)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C, D)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C, D, E)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C, D, E, F)` implements `minicbor::Encode<Ctx>`\n            and 153 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::to_vec`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs:212:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn to_vec<T>(x: T) -> Result<Vec<u8>, encode::Error<Infallible>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m212\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     T: Encode<()>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `to_vec`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `byron::Address: minicbor::Decode<'_, ()>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1486,"byte_end":1510,"line_start":42,"line_end":42,"column_start":20,"column_end":44,"is_primary":true,"text":[{"text":"        let addr = minicbor::decode(&bytes)?;","highlight_start":20,"highlight_end":44}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `minicbor::Decode<'_, ()>` is not implemented for `byron::Address`","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":116,"byte_end":134,"line_start":3,"line_end":3,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"pub struct Address {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following other types implement trait `minicbor::Decode<'b, C>`:\n  `&'a minicbor::bytes::ByteSlice` implements `minicbor::Decode<'b, C>`\n  `&'a std::ffi::CStr` implements `minicbor::Decode<'b, C>`\n  `&'a std::path::Path` implements `minicbor::Decode<'b, C>`\n  `&'a str` implements `minicbor::Decode<'b, C>`\n  `()` implements `minicbor::Decode<'b, C>`\n  `(A, B)` implements `minicbor::Decode<'b, Ctx>`\n  `(A, B, C)` implements `minicbor::Decode<'b, Ctx>`\n  `(A, B, C, D)` implements `minicbor::Decode<'b, Ctx>`\nand 148 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::decode`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","byte_start":5113,"byte_end":5119,"line_start":173,"line_end":173,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"pub fn decode<'b, T>(b: &'b [u8]) -> Result<T, decode::Error>","highlight_start":8,"highlight_end":14}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","byte_start":5181,"byte_end":5195,"line_start":175,"line_end":175,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    T: Decode<'b, ()>","highlight_start":8,"highlight_end":22}],"label":"required by this bound in `decode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `byron::Address: minicbor::Decode<'_, ()>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:42:20\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let addr = minicbor::decode(&bytes)?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Decode<'_, ()>` is not implemented for `byron::Address`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:3:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Address {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `minicbor::Decode<'b, C>`:\n              `&'a minicbor::bytes::ByteSlice` implements `minicbor::Decode<'b, C>`\n              `&'a std::ffi::CStr` implements `minicbor::Decode<'b, C>`\n              `&'a std::path::Path` implements `minicbor::Decode<'b, C>`\n              `&'a str` implements `minicbor::Decode<'b, C>`\n              `()` implements `minicbor::Decode<'b, C>`\n              `(A, B)` implements `minicbor::Decode<'b, Ctx>`\n              `(A, B, C)` implements `minicbor::Decode<'b, Ctx>`\n              `(A, B, C, D)` implements `minicbor::Decode<'b, Ctx>`\n            and 148 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::decode`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs:175:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m173\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn decode<'b, T>(b: &'b [u8]) -> Result<T, decode::Error>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m174\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m175\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     T: Decode<'b, ()>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `decode`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"the trait bound `byron::Address: minicbor::Encode<()>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"ledger/src/byron.rs","byte_start":1614,"byte_end":1618,"line_start":47,"line_end":47,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"        let bytes = minicbor::to_vec(self)","highlight_start":38,"highlight_end":42}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"ledger/src/byron.rs","byte_start":1597,"byte_end":1613,"line_start":47,"line_end":47,"column_start":21,"column_end":37,"is_primary":false,"text":[{"text":"        let bytes = minicbor::to_vec(self)","highlight_start":21,"highlight_end":37}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `minicbor::Encode<()>` is not implemented for `byron::Address`","code":null,"level":"help","spans":[{"file_name":"ledger/src/byron.rs","byte_start":116,"byte_end":134,"line_start":3,"line_end":3,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"pub struct Address {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following other types implement trait `minicbor::Encode<C>`:\n  `&T` implements `minicbor::Encode<C>`\n  `&mut T` implements `minicbor::Encode<C>`\n  `()` implements `minicbor::Encode<C>`\n  `(A, B)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C, D)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C, D, E)` implements `minicbor::Encode<Ctx>`\n  `(A, B, C, D, E, F)` implements `minicbor::Encode<Ctx>`\nand 153 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&byron::Address` to implement `minicbor::Encode<()>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `minicbor::to_vec`","code":null,"level":"note","spans":[{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","byte_start":6104,"byte_end":6110,"line_start":210,"line_end":210,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"pub fn to_vec<T>(x: T) -> Result<Vec<u8>, encode::Error<Infallible>>","highlight_start":8,"highlight_end":14}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs","byte_start":6179,"byte_end":6189,"line_start":212,"line_end":212,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"    T: Encode<()>","highlight_start":8,"highlight_end":18}],"label":"required by this bound in `to_vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `byron::Address: minicbor::Encode<()>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:47:38\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let bytes = minicbor::to_vec(self)\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `minicbor::Encode<()>` is not implemented for `byron::Address`\n   \u001b[1m\u001b[94m--> \u001b[0mledger/src/byron.rs:3:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Address {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `minicbor::Encode<C>`:\n              `&T` implements `minicbor::Encode<C>`\n              `&mut T` implements `minicbor::Encode<C>`\n              `()` implements `minicbor::Encode<C>`\n              `(A, B)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C, D)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C, D, E)` implements `minicbor::Encode<Ctx>`\n              `(A, B, C, D, E, F)` implements `minicbor::Encode<Ctx>`\n            and 153 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&byron::Address` to implement `minicbor::Encode<()>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `minicbor::to_vec`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/charles/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/minicbor-2.1.3/src/lib.rs:212:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn to_vec<T>(x: T) -> Result<Vec<u8>, encode::Error<Infallible>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m212\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     T: Encode<()>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `to_vec`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0308, E0369, E0412, E0432, E0433, E0599, E0631.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0308, E0369, E0412, E0432, E0433, E0599, E0631.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0308, E0369, E0412, E0432, E0433, E0599, E0631.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0308, E0369, E0412, E0432, E0433, E0599, E0631.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/charles/Code/pallas-extras/ledger#0.1.0","manifest_path":"/Users/charles/Code/pallas-extras/ledger/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"ledger","src_path":"/Users/charles/Code/pallas-extras/ledger/src/lib.rs","edition":"2024","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}}
{"reason":"build-finished","success":false}

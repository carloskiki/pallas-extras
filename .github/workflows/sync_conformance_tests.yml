name: Sync Conformance Tests

on:
  # Run the workflow every week
  schedule:
    - cron: '0 0 * * 0' # Every Sunday at midnight UTC

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Environment variables for easy configuration
env:
  REMOTE_REPO: 'IntersectMBO/plutus'
  REMOTE_DIR: 'plutus-conformance/test-cases'
  LOCAL_DIR: 'plutus/tests/conformance'
  SYNC_TAG_FILE: '.last_synced_tag'

jobs:
  check:
    name: Check for new release
    runs-on: ubuntu-latest
    outputs:
      needs_sync: ${{ steps.check_tags.outputs.needs_sync }}
      remote_tag: ${{ steps.get_remote_tag.outputs.remote_tag }}

    steps:
      - name: 1. Checkout current repository
        uses: actions/checkout@v4

      - name: 2. Get latest release tag from remote repo
        id: get_remote_tag
        run: |
          echo "Fetching latest release tag from ${{ env.REMOTE_REPO }}..."
          REMOTE_TAG=$(gh release view --repo ${{ env.REMOTE_REPO }} --json tagName --jq '.tagName')
          if [ -z "$REMOTE_TAG" ]; then
            echo "Could not fetch the latest release tag."
            exit 1
          fi
          echo "Latest remote release tag is $REMOTE_TAG"
          echo "remote_tag=$REMOTE_TAG" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 3. Get last synced release tag
        id: get_local_tag
        run: |
          TAG_FILE="${{ env.LOCAL_DIR }}/${{ env.SYNC_TAG_FILE }}"
          if [ -f "$TAG_FILE" ]; then
            LOCAL_TAG=$(cat "$TAG_FILE")
            echo "Last synced tag is $LOCAL_TAG"
          else
            LOCAL_TAG=""
            echo "No local tag file found. Will perform initial sync."
          fi
          echo "local_tag=$LOCAL_TAG" >> $GITHUB_OUTPUT

      - name: 4. Compare tags and decide to sync
        id: check_tags
        run: |
          if [ "${{ steps.get_remote_tag.outputs.remote_tag }}" != "${{ steps.get_local_tag.outputs.local_tag }}" ]; then
            echo "Tags do not match. A sync is required."
            echo "needs_sync=true" >> $GITHUB_OUTPUT
          else
            echo "Tags match. No sync needed."
            echo "needs_sync=false" >> $GITHUB_OUTPUT
          fi

  sync:
    name: Sync and Process Conformance Tests
    runs-on: ubuntu-latest
    needs: check
    if: needs.check.outputs.needs_sync == 'true'

    permissions:
      contents: write

    steps:
      - name: 1. Checkout current repository
        uses: actions/checkout@v4

      - name: 2. Sync the directory
        run: |
          REMOTE_TAG="${{ needs.check.outputs.remote_tag }}"
          echo "Starting sync from ${{ env.REMOTE_REPO }}@$REMOTE_TAG"

          TEMP_CLONE_DIR="temp_clone"
          mkdir -p $TEMP_CLONE_DIR

          cd $TEMP_CLONE_DIR
          git init
          git remote add origin https://github.com/${{ env.REMOTE_REPO }}.git
          git config core.sparseCheckout true
          echo "${{ env.REMOTE_DIR }}/*" > .git/info/sparse-checkout
          git fetch --depth=1 origin tags/$REMOTE_TAG
          git checkout FETCH_HEAD
          cd ..

          mkdir -p "${{ env.LOCAL_DIR }}"
          rsync -av --delete --exclude=".git" "$TEMP_CLONE_DIR/${{ env.REMOTE_DIR }}/" "${{ env.LOCAL_DIR }}/"
          echo "$REMOTE_TAG" > "${{ env.LOCAL_DIR }}/${{ env.SYNC_TAG_FILE }}"
          rm -rf $TEMP_CLONE_DIR
          echo "Sync complete."

      - name: 3. Remove comments from .uplc files
        run: |
          echo "Removing comments from .uplc files..."
          find "${{ env.LOCAL_DIR }}" -type f -name "*.uplc" -exec python3 -c '
          import sys
          with open(sys.argv[1], "r+") as f:
              content = f.read()
              f.seek(0)
              result, in_string, i = [], False, 0
              while i < len(content):
                  if content[i:i+2] == "\\\\": result.append(content[i:i+2]); i += 2
                  elif content[i:i+2] == "\\\"": result.append(content[i:i+2]); i += 2
                  elif content[i] == "\"": in_string = not in_string; result.append(content[i]); i += 1
                  elif not in_string and content[i:i+2] == "--":
                      i = content.find("\n", i)
                      if i == -1: break
                      result.append("\n"); i += 1
                  else: result.append(content[i]); i += 1
              f.write("".join(result))
              f.truncate()
          ' {} \;
          echo "Comment removal complete."

      - name: 4. Download uplc binary
        run: |
          REMOTE_TAG="${{ needs.check.outputs.remote_tag }}"
          echo "Downloading new uplc binary for release $REMOTE_TAG..."
          mkdir -p ${{ runner.tool_cache }}/uplc
          gh release download $REMOTE_TAG --repo ${{ env.REMOTE_REPO }} --pattern 'uplc-x86_64-linux*' --output ${{ runner.tool_cache }}/uplc/uplc
          chmod +x ${{ runner.tool_cache }}/uplc/uplc
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 5. Add uplc to PATH
        run: |
          echo "${{ runner.tool_cache }}/uplc" >> $GITHUB_PATH

      - name: 6. Verify uplc installation
        run: |
          echo "Verifying uplc installation..."
          uplc --version

      - name: 7. Generate flat UPLC files
        run: |
          TARGET_DIR="${{ env.LOCAL_DIR }}"
          echo "Starting processing in $TARGET_DIR..."
          find "$TARGET_DIR" -type d | while read -r dir; do
            if [ -z "$(find "$dir" -mindepth 1 -maxdepth 1 -type d)" ]; then
              dirname=$(basename "$dir")
              echo "--- Processing leaf directory: $dirname ---"
              input_uplc="$dir/$dirname.uplc"
              output_flat="$dir/$dirname.flat"
              if [ -f "$input_uplc" ]; then
                echo "Attempting to convert files for $dirname..."
                uplc convert -i "$input_uplc" -o "$output_flat" --of flat || {
                  echo "Conversion failed for $input_uplc, continuing..."
                  rm -f -- "$output_flat" # Remove incomplete or empty output file, if any
                }
              else
                echo "Warning: Skipping $dir. Missing expected files."
              fi
            fi
          done
          echo "--- Processing finished ---"

      - name: 8. Commit and push changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(conformance): Sync tests from ${{ env.REMOTE_REPO }}@${{ needs.check.outputs.remote_tag }}"
          file_pattern: "${{ env.LOCAL_DIR }}/**"
          commit_user_name: "github-actions[bot]"
          commit_user_email: "41898282+github-actions[bot]@users.noreply.github.com"
